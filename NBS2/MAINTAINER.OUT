/* COMMANDS */
#define C_QUEST                          1 /* ?                              */
#define C_CALL                           2 /* CALL                           */
#define C_CASE                           3 /* CASE                           */
#define C_CASE_ELSE                      4 /* CASE ELSE                      */
#define C_CASE_IF                        5 /* CASE IF                        */
#define C_CASE_IS                        6 /* CASE IS                        */
#define C_CHAIN                          7 /* CHAIN                          */
#define C_CHANGE                         8 /* CHANGE                         */
#define C_CLEAR                          9 /* CLEAR                          */
#define C_CLOAD                         10 /* CLOAD                          */
#define C_CLOAD_                        11 /* CLOAD*                         */
#define C_CMDS                          12 /* CMDS                           */
#define C_COMMON                        13 /* COMMON                         */
#define C_CONT                          14 /* CONT                           */
#define C_CSAVE                         15 /* CSAVE                          */
#define C_CSAVE_                        16 /* CSAVE*                         */
#define C_DATA                          17 /* DATA                           */
#define C_DEF                           18 /* DEF                            */
#define C_DEF_SUB                       19 /* DEF SUB                        */
#define C_DEFDBL                        20 /* DEFDBL                         */
#define C_DEFINT                        21 /* DEFINT                         */
#define C_DEFSNG                        22 /* DEFSNG                         */
#define C_DEFSTR                        23 /* DEFSTR                         */
#define C_DELETE                        24 /* DELETE                         */
#define C_DIM                           25 /* DIM                            */
#define C_DO                            26 /* DO                             */
#define C_DO_UNTIL                      27 /* DO UNTIL                       */
#define C_DO_WHILE                      28 /* DO WHILE                       */
#define C_EDIT                          29 /* EDIT                           */
#define C_ELSE                          30 /* ELSE                           */
#define C_ELSEIF                        31 /* ELSEIF                         */
#define C_END                           32 /* END                            */
#define C_END_FUNCTION                  33 /* END FUNCTION                   */
#define C_END_IF                        34 /* END IF                         */
#define C_END_SELECT                    35 /* END SELECT                     */
#define C_END_SUB                       36 /* END SUB                        */
#define C_ERASE                         37 /* ERASE                          */
#define C_EXIT                          38 /* EXIT                           */
#define C_EXIT_DO                       39 /* EXIT DO                        */
#define C_EXIT_FOR                      40 /* EXIT FOR                       */
#define C_EXIT_FUNCTION                 41 /* EXIT FUNCTION                  */
#define C_EXIT_SUB                      42 /* EXIT SUB                       */
#define C_EXIT_UNTIL                    43 /* EXIT UNTIL                     */
#define C_EXIT_WHILE                    44 /* EXIT WHILE                     */
#define C_FIELD                         45 /* FIELD                          */
#define C_FNCS                          46 /* FNCS                           */
#define C_FOR                           47 /* FOR                            */
#define C_FUNCTION                      48 /* FUNCTION                       */
#define C_GO                            49 /* GO                             */
#define C_GOSUB                         50 /* GOSUB                          */
#define C_GOTO                          51 /* GOTO                           */
#define C_HELP                          52 /* HELP                           */
#define C_IF                            53 /* IF                             */
#define C_IF_THEN                       54 /* IF THEN                        */
#define C_INPUT                         55 /* INPUT                          */
#define C_LET                           56 /* LET                            */
#define C_LINE                          57 /* LINE                           */
#define C_LIST                          58 /* LIST                           */
#define C_LOAD                          59 /* LOAD                           */
#define C_LOOP                          60 /* LOOP                           */
#define C_LOOP_UNTIL                    61 /* LOOP UNTIL                     */
#define C_LOOP_WHILE                    62 /* LOOP WHILE                     */
#define C_LPRINT                        63 /* LPRINT                         */
#define C_LSET                          64 /* LSET                           */
#define C_MAINTAINER                    65 /* MAINTAINER                     */
#define C_MERGE                         66 /* MERGE                          */
#define C_MID_                          67 /* MID$                           */
#define C_NAME                          68 /* NAME                           */
#define C_NEW                           69 /* NEW                            */
#define C_NEXT                          70 /* NEXT                           */
#define C_ON                            71 /* ON                             */
#define C_ON_ERROR_GOSUB                72 /* ON ERROR GOSUB                 */
#define C_ON_ERROR_GOTO                 73 /* ON ERROR GOTO                  */
#define C_ON_ERROR_RESUME_NEXT          74 /* ON ERROR RESUME NEXT           */
#define C_ON_ERROR_RETURN_NEXT          75 /* ON ERROR RETURN NEXT           */
#define C_ON_TIMER                      76 /* ON TIMER                       */
#define C_OPEN                          77 /* OPEN                           */
#define C_OPTION                        78 /* OPTION                         */
#define C_OPTION_ANGLE_DEGREES          79 /* OPTION ANGLE DEGREES           */
#define C_OPTION_ANGLE_RADIANS          80 /* OPTION ANGLE RADIANS           */
#define C_OPTION_ARITHMETIC_DECIMAL     81 /* OPTION ARITHMETIC DECIMAL      */
#define C_OPTION_ARITHMETIC_FIXED       82 /* OPTION ARITHMETIC FIXED        */
#define C_OPTION_ARITHMETIC_NATIVE      83 /* OPTION ARITHMETIC NATIVE       */
#define C_OPTION_BASE_0                 84 /* OPTION BASE 0                  */
#define C_OPTION_BASE_1                 85 /* OPTION BASE 1                  */
#define C_OPTION_BUGS_OFF               86 /* OPTION BUGS OFF                */
#define C_OPTION_BUGS_ON                87 /* OPTION BUGS ON                 */
#define C_OPTION_COMMENT                88 /* OPTION COMMENT                 */
#define C_OPTION_COMPARE_BINARY         89 /* OPTION COMPARE BINARY          */
#define C_OPTION_COMPARE_DATABASE       90 /* OPTION COMPARE DATABASE        */
#define C_OPTION_COMPARE_TEXT           91 /* OPTION COMPARE TEXT            */
#define C_OPTION_COVERAGE_OFF           92 /* OPTION COVERAGE OFF            */
#define C_OPTION_COVERAGE_ON            93 /* OPTION COVERAGE ON             */
#define C_OPTION_DATE                   94 /* OPTION DATE                    */
#define C_OPTION_DISABLE_COMMAND        95 /* OPTION DISABLE COMMAND         */
#define C_OPTION_DISABLE_FUNCTION       96 /* OPTION DISABLE FUNCTION        */
#define C_OPTION_DISABLE_OPERATOR       97 /* OPTION DISABLE OPERATOR        */
#define C_OPTION_ENABLE_COMMAND         98 /* OPTION ENABLE COMMAND          */
#define C_OPTION_ENABLE_FUNCTION        99 /* OPTION ENABLE FUNCTION         */
#define C_OPTION_ENABLE_OPERATOR       100 /* OPTION ENABLE OPERATOR         */
#define C_OPTION_ERROR_GOSUB           101 /* OPTION ERROR GOSUB             */
#define C_OPTION_ERROR_GOTO            102 /* OPTION ERROR GOTO              */
#define C_OPTION_INDENT                103 /* OPTION INDENT                  */
#define C_OPTION_LABELS_OFF            104 /* OPTION LABELS OFF              */
#define C_OPTION_LABELS_ON             105 /* OPTION LABELS ON               */
#define C_OPTION_STATEMENT             106 /* OPTION STATEMENT               */
#define C_OPTION_STRICT_OFF            107 /* OPTION STRICT OFF              */
#define C_OPTION_STRICT_ON             108 /* OPTION STRICT ON               */
#define C_OPTION_TERMINAL_ADM_3A       109 /* OPTION TERMINAL ADM-3A         */
#define C_OPTION_TERMINAL_ANSI         110 /* OPTION TERMINAL ANSI           */
#define C_OPTION_TERMINAL_NONE         111 /* OPTION TERMINAL NONE           */
#define C_OPTION_TIME                  112 /* OPTION TIME                    */
#define C_OPTION_TRACE_OFF             113 /* OPTION TRACE OFF               */
#define C_OPTION_TRACE_ON              114 /* OPTION TRACE ON                */
#define C_OPTION_VERSION               115 /* OPTION VERSION                 */
#define C_PRINT                        116 /* PRINT                          */
#define C_QUIT                         117 /* QUIT                           */
#define C_READ                         118 /* READ                           */
#define C_REM                          119 /* REM                            */
#define C_RENUM                        120 /* RENUM                          */
#define C_RESTORE                      121 /* RESTORE                        */
#define C_RESUME                       122 /* RESUME                         */
#define C_RETURN                       123 /* RETURN                         */
#define C_RSET                         124 /* RSET                           */
#define C_RUN                          125 /* RUN                            */
#define C_SAVE                         126 /* SAVE                           */
#define C_SELECT                       127 /* SELECT                         */
#define C_SELECT_CASE                  128 /* SELECT CASE                    */
#define C_STOP                         129 /* STOP                           */
#define C_SUB                          130 /* SUB                            */
#define C_SWAP                         131 /* SWAP                           */
#define C_SYSTEM                       132 /* SYSTEM                         */
#define C_TIMER                        133 /* TIMER                          */
#define C_TIMER_OFF                    134 /* TIMER OFF                      */
#define C_TIMER_ON                     135 /* TIMER ON                       */
#define C_TIMER_STOP                   136 /* TIMER STOP                     */
#define C_UEND                         137 /* UEND                           */
#define C_UNTIL                        138 /* UNTIL                          */
#define C_USER_LBL                     139 /* USER LBL                       */
#define C_VARS                         140 /* VARS                           */
#define C_WEND                         141 /* WEND                           */
#define C_WHILE                        142 /* WHILE                          */
#define C_WRITE                        143 /* WRITE                          */
#define NUM_COMMANDS 143
/* SWITCH */
struct bwb_line *bwb_vector( struct bwb_line *l )
{
   struct bwb_line *r;
   switch( l->cmdnum )
   {
   case C_QUEST:
      r = bwb_QUEST( l );
      break;
   case C_CALL:
      r = bwb_CALL( l );
      break;
   case C_CASE:
      r = bwb_CASE( l );
      break;
   case C_CASE_ELSE:
      r = bwb_CASE_ELSE( l );
      break;
   case C_CASE_IF:
      r = bwb_CASE_IF( l );
      break;
   case C_CASE_IS:
      r = bwb_CASE_IS( l );
      break;
   case C_CHAIN:
      r = bwb_CHAIN( l );
      break;
   case C_CHANGE:
      r = bwb_CHANGE( l );
      break;
   case C_CLEAR:
      r = bwb_CLEAR( l );
      break;
   case C_CLOAD:
      r = bwb_CLOAD( l );
      break;
   case C_CLOAD_:
      r = bwb_CLOAD_( l );
      break;
   case C_CMDS:
      r = bwb_CMDS( l );
      break;
   case C_COMMON:
      r = bwb_COMMON( l );
      break;
   case C_CONT:
      r = bwb_CONT( l );
      break;
   case C_CSAVE:
      r = bwb_CSAVE( l );
      break;
   case C_CSAVE_:
      r = bwb_CSAVE_( l );
      break;
   case C_DATA:
      r = bwb_DATA( l );
      break;
   case C_DEF:
      r = bwb_DEF( l );
      break;
   case C_DEF_SUB:
      r = bwb_DEF_SUB( l );
      break;
   case C_DEFDBL:
      r = bwb_DEFDBL( l );
      break;
   case C_DEFINT:
      r = bwb_DEFINT( l );
      break;
   case C_DEFSNG:
      r = bwb_DEFSNG( l );
      break;
   case C_DEFSTR:
      r = bwb_DEFSTR( l );
      break;
   case C_DELETE:
      r = bwb_DELETE( l );
      break;
   case C_DIM:
      r = bwb_DIM( l );
      break;
   case C_DO:
      r = bwb_DO( l );
      break;
   case C_DO_UNTIL:
      r = bwb_DO_UNTIL( l );
      break;
   case C_DO_WHILE:
      r = bwb_DO_WHILE( l );
      break;
   case C_EDIT:
      r = bwb_EDIT( l );
      break;
   case C_ELSE:
      r = bwb_ELSE( l );
      break;
   case C_ELSEIF:
      r = bwb_ELSEIF( l );
      break;
   case C_END:
      r = bwb_END( l );
      break;
   case C_END_FUNCTION:
      r = bwb_END_FUNCTION( l );
      break;
   case C_END_IF:
      r = bwb_END_IF( l );
      break;
   case C_END_SELECT:
      r = bwb_END_SELECT( l );
      break;
   case C_END_SUB:
      r = bwb_END_SUB( l );
      break;
   case C_ERASE:
      r = bwb_ERASE( l );
      break;
   case C_EXIT:
      r = bwb_EXIT( l );
      break;
   case C_EXIT_DO:
      r = bwb_EXIT_DO( l );
      break;
   case C_EXIT_FOR:
      r = bwb_EXIT_FOR( l );
      break;
   case C_EXIT_FUNCTION:
      r = bwb_EXIT_FUNCTION( l );
      break;
   case C_EXIT_SUB:
      r = bwb_EXIT_SUB( l );
      break;
   case C_EXIT_UNTIL:
      r = bwb_EXIT_UNTIL( l );
      break;
   case C_EXIT_WHILE:
      r = bwb_EXIT_WHILE( l );
      break;
   case C_FIELD:
      r = bwb_FIELD( l );
      break;
   case C_FNCS:
      r = bwb_FNCS( l );
      break;
   case C_FOR:
      r = bwb_FOR( l );
      break;
   case C_FUNCTION:
      r = bwb_FUNCTION( l );
      break;
   case C_GO:
      r = bwb_GO( l );
      break;
   case C_GOSUB:
      r = bwb_GOSUB( l );
      break;
   case C_GOTO:
      r = bwb_GOTO( l );
      break;
   case C_HELP:
      r = bwb_HELP( l );
      break;
   case C_IF:
      r = bwb_IF( l );
      break;
   case C_IF_THEN:
      r = bwb_IF_THEN( l );
      break;
   case C_INPUT:
      r = bwb_INPUT( l );
      break;
   case C_LET:
      r = bwb_LET( l );
      break;
   case C_LINE:
      r = bwb_LINE( l );
      break;
   case C_LIST:
      r = bwb_LIST( l );
      break;
   case C_LOAD:
      r = bwb_LOAD( l );
      break;
   case C_LOOP:
      r = bwb_LOOP( l );
      break;
   case C_LOOP_UNTIL:
      r = bwb_LOOP_UNTIL( l );
      break;
   case C_LOOP_WHILE:
      r = bwb_LOOP_WHILE( l );
      break;
   case C_LPRINT:
      r = bwb_LPRINT( l );
      break;
   case C_LSET:
      r = bwb_LSET( l );
      break;
   case C_MAINTAINER:
      r = bwb_MAINTAINER( l );
      break;
   case C_MERGE:
      r = bwb_MERGE( l );
      break;
   case C_MID_:
      r = bwb_MID_( l );
      break;
   case C_NAME:
      r = bwb_NAME( l );
      break;
   case C_NEW:
      r = bwb_NEW( l );
      break;
   case C_NEXT:
      r = bwb_NEXT( l );
      break;
   case C_ON:
      r = bwb_ON( l );
      break;
   case C_ON_ERROR_GOSUB:
      r = bwb_ON_ERROR_GOSUB( l );
      break;
   case C_ON_ERROR_GOTO:
      r = bwb_ON_ERROR_GOTO( l );
      break;
   case C_ON_ERROR_RESUME_NEXT:
      r = bwb_ON_ERROR_RESUME_NEXT( l );
      break;
   case C_ON_ERROR_RETURN_NEXT:
      r = bwb_ON_ERROR_RETURN_NEXT( l );
      break;
   case C_ON_TIMER:
      r = bwb_ON_TIMER( l );
      break;
   case C_OPEN:
      r = bwb_OPEN( l );
      break;
   case C_OPTION:
      r = bwb_OPTION( l );
      break;
   case C_OPTION_ANGLE_DEGREES:
      r = bwb_OPTION_ANGLE_DEGREES( l );
      break;
   case C_OPTION_ANGLE_RADIANS:
      r = bwb_OPTION_ANGLE_RADIANS( l );
      break;
   case C_OPTION_ARITHMETIC_DECIMAL:
      r = bwb_OPTION_ARITHMETIC_DECIMAL( l );
      break;
   case C_OPTION_ARITHMETIC_FIXED:
      r = bwb_OPTION_ARITHMETIC_FIXED( l );
      break;
   case C_OPTION_ARITHMETIC_NATIVE:
      r = bwb_OPTION_ARITHMETIC_NATIVE( l );
      break;
   case C_OPTION_BASE_0:
      r = bwb_OPTION_BASE_0( l );
      break;
   case C_OPTION_BASE_1:
      r = bwb_OPTION_BASE_1( l );
      break;
   case C_OPTION_BUGS_OFF:
      r = bwb_OPTION_BUGS_OFF( l );
      break;
   case C_OPTION_BUGS_ON:
      r = bwb_OPTION_BUGS_ON( l );
      break;
   case C_OPTION_COMMENT:
      r = bwb_OPTION_COMMENT( l );
      break;
   case C_OPTION_COMPARE_BINARY:
      r = bwb_OPTION_COMPARE_BINARY( l );
      break;
   case C_OPTION_COMPARE_DATABASE:
      r = bwb_OPTION_COMPARE_DATABASE( l );
      break;
   case C_OPTION_COMPARE_TEXT:
      r = bwb_OPTION_COMPARE_TEXT( l );
      break;
   case C_OPTION_COVERAGE_OFF:
      r = bwb_OPTION_COVERAGE_OFF( l );
      break;
   case C_OPTION_COVERAGE_ON:
      r = bwb_OPTION_COVERAGE_ON( l );
      break;
   case C_OPTION_DATE:
      r = bwb_OPTION_DATE( l );
      break;
   case C_OPTION_DISABLE_COMMAND:
      r = bwb_OPTION_DISABLE_COMMAND( l );
      break;
   case C_OPTION_DISABLE_FUNCTION:
      r = bwb_OPTION_DISABLE_FUNCTION( l );
      break;
   case C_OPTION_DISABLE_OPERATOR:
      r = bwb_OPTION_DISABLE_OPERATOR( l );
      break;
   case C_OPTION_ENABLE_COMMAND:
      r = bwb_OPTION_ENABLE_COMMAND( l );
      break;
   case C_OPTION_ENABLE_FUNCTION:
      r = bwb_OPTION_ENABLE_FUNCTION( l );
      break;
   case C_OPTION_ENABLE_OPERATOR:
      r = bwb_OPTION_ENABLE_OPERATOR( l );
      break;
   case C_OPTION_ERROR_GOSUB:
      r = bwb_OPTION_ERROR_GOSUB( l );
      break;
   case C_OPTION_ERROR_GOTO:
      r = bwb_OPTION_ERROR_GOTO( l );
      break;
   case C_OPTION_INDENT:
      r = bwb_OPTION_INDENT( l );
      break;
   case C_OPTION_LABELS_OFF:
      r = bwb_OPTION_LABELS_OFF( l );
      break;
   case C_OPTION_LABELS_ON:
      r = bwb_OPTION_LABELS_ON( l );
      break;
   case C_OPTION_STATEMENT:
      r = bwb_OPTION_STATEMENT( l );
      break;
   case C_OPTION_STRICT_OFF:
      r = bwb_OPTION_STRICT_OFF( l );
      break;
   case C_OPTION_STRICT_ON:
      r = bwb_OPTION_STRICT_ON( l );
      break;
   case C_OPTION_TERMINAL_ADM_3A:
      r = bwb_OPTION_TERMINAL_ADM_3A( l );
      break;
   case C_OPTION_TERMINAL_ANSI:
      r = bwb_OPTION_TERMINAL_ANSI( l );
      break;
   case C_OPTION_TERMINAL_NONE:
      r = bwb_OPTION_TERMINAL_NONE( l );
      break;
   case C_OPTION_TIME:
      r = bwb_OPTION_TIME( l );
      break;
   case C_OPTION_TRACE_OFF:
      r = bwb_OPTION_TRACE_OFF( l );
      break;
   case C_OPTION_TRACE_ON:
      r = bwb_OPTION_TRACE_ON( l );
      break;
   case C_OPTION_VERSION:
      r = bwb_OPTION_VERSION( l );
      break;
   case C_PRINT:
      r = bwb_PRINT( l );
      break;
   case C_QUIT:
      r = bwb_QUIT( l );
      break;
   case C_READ:
      r = bwb_READ( l );
      break;
   case C_REM:
      r = bwb_REM( l );
      break;
   case C_RENUM:
      r = bwb_RENUM( l );
      break;
   case C_RESTORE:
      r = bwb_RESTORE( l );
      break;
   case C_RESUME:
      r = bwb_RESUME( l );
      break;
   case C_RETURN:
      r = bwb_RETURN( l );
      break;
   case C_RSET:
      r = bwb_RSET( l );
      break;
   case C_RUN:
      r = bwb_RUN( l );
      break;
   case C_SAVE:
      r = bwb_SAVE( l );
      break;
   case C_SELECT:
      r = bwb_SELECT( l );
      break;
   case C_SELECT_CASE:
      r = bwb_SELECT_CASE( l );
      break;
   case C_STOP:
      r = bwb_STOP( l );
      break;
   case C_SUB:
      r = bwb_SUB( l );
      break;
   case C_SWAP:
      r = bwb_SWAP( l );
      break;
   case C_SYSTEM:
      r = bwb_SYSTEM( l );
      break;
   case C_TIMER:
      r = bwb_TIMER( l );
      break;
   case C_TIMER_OFF:
      r = bwb_TIMER_OFF( l );
      break;
   case C_TIMER_ON:
      r = bwb_TIMER_ON( l );
      break;
   case C_TIMER_STOP:
      r = bwb_TIMER_STOP( l );
      break;
   case C_UEND:
      r = bwb_UEND( l );
      break;
   case C_UNTIL:
      r = bwb_UNTIL( l );
      break;
   case C_USER_LBL:
      r = bwb_USER_LBL( l );
      break;
   case C_VARS:
      r = bwb_VARS( l );
      break;
   case C_WEND:
      r = bwb_WEND( l );
      break;
   case C_WHILE:
      r = bwb_WHILE( l );
      break;
   case C_WRITE:
      r = bwb_WRITE( l );
      break;
   default:
      sprintf( bwb_ebuf, "in bwb_vector(), INTERNAL ERROR: %d not in switch", l->cmdnum );
      bwb_error( bwb_ebuf );
      r = l;
      break;
   }
   return r;
}
/* COMMAND TABLE */

#include "bwbasic.h"

struct bwb_command bwb_cmdtable[ NUM_COMMANDS ] =
{
{
   C_QUEST,  /* UniqueID */
   "? expressions...",  /* Syntax */
   "This is just a shortcut for PRINT.",  /* Description */
   "?",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_CALL,  /* UniqueID */
   "CALL subroutine-name( [parameter [, ...] ] )",  /* Syntax */
   "Calls a subroutine that was defined by SUB and END SUB.",  /* Description */
   "CALL",  /* Name */
   B14 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_CASE,  /* UniqueID */
   "CASE constant",  /* Syntax */
   "Introduces an element of a SELECT CASE statement.",  /* Description */
   "CASE",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_CASE_ELSE,  /* UniqueID */
   "CASE ELSE",  /* Syntax */
   "Introduces a default SELECT CASE element.",  /* Description */
   "CASE ELSE",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_CASE_IF,  /* UniqueID */
   "CASE IF partial-expression",  /* Syntax */
   "Introduces a conditional SELECT CASE element.",  /* Description */
   "CASE IF",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_CASE_IS,  /* UniqueID */
   "CASE IS",  /* Syntax */
   "Same as CASE IF.",  /* Description */
   "CASE IS",  /* Name */
   B14 | E86  /* OptionVersionBitmask */
},
{
   C_CHAIN,  /* UniqueID */
   "CHAIN filename$",  /* Syntax */
   "Load and execute another BASIC program, without clearing vari"
"ables.",  /* Description */
   "CHAIN",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_CHANGE,  /* UniqueID */
   "CHANGE A$ TO X | CHANGE X TO A$",  /* Syntax */
   "Changes a string to a numeric array or a numeric array to a s"
"tring.",  /* Description */
   "CHANGE",  /* Name */
   B14 | D64  /* OptionVersionBitmask */
},
{
   C_CLEAR,  /* UniqueID */
   "CLEAR",  /* Syntax */
   "Sets all numeric variables to 0, and all string variables to "
"empty strings.",  /* Description */
   "CLEAR",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_CLOAD,  /* UniqueID */
   "CLOAD [file-name$]",  /* Syntax */
   "Loads an ASCII BASIC program into memory.",  /* Description */
   "CLOAD",  /* Name */
   B14 | M80 | T83 | T84 | M85  /* OptionVersionBitmask */
},
{
   C_CLOAD_,  /* UniqueID */
   "CLOAD* ArrayName",  /* Syntax */
   "Loads a numeric array from a file saved using CSAVE*.",  /* Description */
   "CLOAD*",  /* Name */
   B14 | M80 | T83 | T84 | M85  /* OptionVersionBitmask */
},
{
   C_CMDS,  /* UniqueID */
   "CMDS",  /* Syntax */
   "Prints a list of all implemented BASIC commands.",  /* Description */
   "CMDS",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_COMMON,  /* UniqueID */
   "COMMON variable [, ...]",  /* Syntax */
   "Designates variables to be passed to a CHAINed program.",  /* Description */
   "COMMON",  /* Name */
   B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_CONT,  /* UniqueID */
   "CONT",  /* Syntax */
   "Continue a BASIC program after a STOP has been executed.  Pro"
"gram resumes at the line after the STOP.",  /* Description */
   "CONT",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_CSAVE,  /* UniqueID */
   "CSAVE [file-name$]",  /* Syntax */
   "Saves the current program into the file file-name$ in ASCII f"
"ormat.",  /* Description */
   "CSAVE",  /* Name */
   B14 | M80 | T83 | T84 | M85  /* OptionVersionBitmask */
},
{
   C_CSAVE_,  /* UniqueID */
   "CSAVE* ArrayName",  /* Syntax */
   "Saves a numeric array into a file.",  /* Description */
   "CSAVE*",  /* Name */
   B14 | M80 | T83 | T84 | M85  /* OptionVersionBitmask */
},
{
   C_DATA,  /* UniqueID */
   "DATA constant [, ...]",  /* Syntax */
   "Stores numeric and string constants to be accessed by READ.",  /* Description */
   "DATA",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_DEF,  /* UniqueID */
   "DEF FNname(arg...)] = expression",  /* Syntax */
   "Defines a single line user-written function.  For multiple li"
"ne functions use the FUNCTION command.",  /* Description */
   "DEF",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_DEF_SUB,  /* UniqueID */
   "DEF SUB",  /* Syntax */
   "An internal command that allows the BASIC program to execute "
"any function as though it were a command.  You do not directl"
"y call this command.  If your program has a line  beginning w"
"ith a functio name, then DEF SUB is used to execute the funct"
"ion and ignore the result.",  /* Description */
   "DEF SUB",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_DEFDBL,  /* UniqueID */
   "DEFDBL letter[-letter] [, ...]",  /* Syntax */
   "Declares variables with single-letter names as numeric variab"
"les.  TODO: enforce the rnage of [MINDBL,MAXDBL].",  /* Description */
   "DEFDBL",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_DEFINT,  /* UniqueID */
   "DEFINT  letter[-letter] [, ...]",  /* Syntax */
   "Declares variables with single-letter names as numeric variab"
"les.  TODO: enforce the rnage of [MININT,MAXINT].",  /* Description */
   "DEFINT",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_DEFSNG,  /* UniqueID */
   "DEFSNG letter[-letter] [, ...]",  /* Syntax */
   "Declares variables with single-letter names as numeric variab"
"les.  TODO: enforce the rnage of [MINSNG,MAXSNG].",  /* Description */
   "DEFSNG",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_DEFSTR,  /* UniqueID */
   "DEFSTR letter[-letter] [, ...]",  /* Syntax */
   "Declares variables with single-letter names as string variabl"
"es.  TODO: enforce the range of [MINLEN,MAXLEN].",  /* Description */
   "DEFSTR",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_DELETE,  /* UniqueID */
   "DELETE line [- line]",  /* Syntax */
   "Deletes program lines indicated by the argument(s).  All prog"
"ram lines have a number, which is visible with the LIST comma"
"nd.  If line numbers are not provided, they are assigned begi"
"nning with 1.",  /* Description */
   "DELETE",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_DIM,  /* UniqueID */
   "DIM variable( elements [, ...]) [, ...]",  /* Syntax */
   "Specifies the dimensions of an array variables.",  /* Description */
   "DIM",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_DO,  /* UniqueID */
   "DO",  /* Syntax */
   "Top of a DO - LOOP structure.  If the loop is not terminated "
"by EXIT DO or LOOP UNTIL or LOOP WHILE, then it will loop for"
"ever.",  /* Description */
   "DO",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_DO_UNTIL,  /* UniqueID */
   "DO UNTIL expression",  /* Syntax */
   "Top of a DO - LOOP structure.  If the expression is zero, the"
"n the loop is terminated.",  /* Description */
   "DO UNTIL",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_DO_WHILE,  /* UniqueID */
   "DO WHILE expression",  /* Syntax */
   "Top of a DO - LOOP structure.  If the expression is non-zero,"
" then the loop is terminated.",  /* Description */
   "DO WHILE",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_EDIT,  /* UniqueID */
   "EDIT",  /* Syntax */
   "implementation defined.",  /* Description */
   "EDIT",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_ELSE,  /* UniqueID */
   "ELSE",  /* Syntax */
   "Introduces a default condition in a multi-line IF statement.",  /* Description */
   "ELSE",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_ELSEIF,  /* UniqueID */
   "ELSEIF",  /* Syntax */
   "Introduces a secondary condition in a multi-line IF statement"
".",  /* Description */
   "ELSEIF",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_END,  /* UniqueID */
   "END",  /* Syntax */
   "Terminates program execution. If the BASIC program was execut"
"ed from the operating system level, then control returns to t"
"he operating system, oterwise control reuturns to the BASIC p"
"rompt.",  /* Description */
   "END",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_END_FUNCTION,  /* UniqueID */
   "END FUNCTION",  /* Syntax */
   "Specifies the last line of a multi-line FUNCTION definition.",  /* Description */
   "END FUNCTION",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_END_IF,  /* UniqueID */
   "END IF",  /* Syntax */
   "Specifies the last line of a multi-line IF definition.",  /* Description */
   "END IF",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_END_SELECT,  /* UniqueID */
   "END SELECT",  /* Syntax */
   "Specifies the last line of a multi-line SELECT CASE definitio"
"n.",  /* Description */
   "END SELECT",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_END_SUB,  /* UniqueID */
   "END SUB",  /* Syntax */
   "Specifies the last line of a multi-line SUB definition.",  /* Description */
   "END SUB",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_ERASE,  /* UniqueID */
   "ERASE variable [, ...]",  /* Syntax */
   "Eliminates arrayed variables from a program.",  /* Description */
   "ERASE",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_EXIT,  /* UniqueID */
   "EXIT",  /* Syntax */
   "EXIT by itself is a syntax error.  Use EXIT DO, EXIT FOR, EXI"
"T FUNCTION, EXIT SUB, EXIT UNTIL, or EXIT WHILE.",  /* Description */
   "EXIT",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_EXIT_DO,  /* UniqueID */
   "EXIT DO",  /* Syntax */
   "Immediately exits the inner-most DO-LOOP strucure.",  /* Description */
   "EXIT DO",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_EXIT_FOR,  /* UniqueID */
   "EXIT FOR",  /* Syntax */
   "Immediately exits the inner-most FOR-NEXT strucure.",  /* Description */
   "EXIT FOR",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_EXIT_FUNCTION,  /* UniqueID */
   "EXIT FUNCTION",  /* Syntax */
   "Immediately exits the inner-most multi-line FUNCTION strucure"
".",  /* Description */
   "EXIT FUNCTION",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_EXIT_SUB,  /* UniqueID */
   "EXIT SUB",  /* Syntax */
   "Immediately exits the inner-most multi-line SUB strucure.",  /* Description */
   "EXIT SUB",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_EXIT_UNTIL,  /* UniqueID */
   "EXIT UNTIL",  /* Syntax */
   "Immediately exits the inner-most UNTIL-UEND strucure.",  /* Description */
   "EXIT UNTIL",  /* Name */
   B14 | E86  /* OptionVersionBitmask */
},
{
   C_EXIT_WHILE,  /* UniqueID */
   "EXIT WHILE",  /* Syntax */
   "Immediately exits the inner-most WHILE-END strucure.",  /* Description */
   "EXIT WHILE",  /* Name */
   B14 | E86  /* OptionVersionBitmask */
},
{
   C_FIELD,  /* UniqueID */
   "FIELD [#] device-number, number AS string-variable$ [, ...]",  /* Syntax */
   "Assigns 'number' bytes in the buffer of random file 'device-n"
"umber' to the variable 'string-variable$'.  GET will automati"
"cally update the variable, and PUT will automatically use the"
" variable.",  /* Description */
   "FIELD",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_FNCS,  /* UniqueID */
   "FNCS",  /* Syntax */
   "Prints a list of all pre-defined BASIC functions.",  /* Description */
   "FNCS",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_FOR,  /* UniqueID */
   "FOR variable = start TO finish [STEP increment]",  /* Syntax */
   "Top of a FOR - NEXT structure.  The loop will continue a fixe"
"d number of times, which is determined by the values of start"
", finish, and increment.",  /* Description */
   "FOR",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_FUNCTION,  /* UniqueID */
   "FUNCTION [ ( parameter [, ...  ] ) ]",  /* Syntax */
   "Top line of a multi-line FUNCTION definition.  The variable n"
"ames specified are local to the FUNCTION definition, and are "
"initialized BYVAL when the function is invoked by another rou"
"tine.",  /* Description */
   "FUNCTION",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_GO,  /* UniqueID */
   "GO",  /* Syntax */
   "GO by itself is a syntax error.  Use GOTO or GOSUB instead.",  /* Description */
   "GO",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_GOSUB,  /* UniqueID */
   "GOSUB line",  /* Syntax */
   "Initiates a subroutine call to the line specified.  The subro"
"utine must end with RETURN.  The 'line' may be a number or a "
"label.",  /* Description */
   "GOSUB",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_GOTO,  /* UniqueID */
   "GOTO line",  /* Syntax */
   "Branches program execution to the specified line.  The 'line'"
" may be a number or a label.",  /* Description */
   "GOTO",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_HELP,  /* UniqueID */
   "HELP name",  /* Syntax */
   "Provides help on the specified 'name' which is a command name"
" or function name.",  /* Description */
   "HELP",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_IF,  /* UniqueID */
   "IF expression THEN line1 [ELSE line2]",  /* Syntax */
   "Single line standard IF command.  If the value of expression "
"is non-zero, then branh to line1.  If the value of expression"
" is zero and ELSE is provided, then branch to line2.  If the "
"value of expression is zero and ELSE is not provided, continu"
"e to the next line.  LABELS are not allowed.",  /* Description */
   "IF",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_IF_THEN,  /* UniqueID */
   "IF expression THEN",  /* Syntax */
   "Top of a multi-line IF - END IF structure.  If the value of e"
"xpression is non-zero, then the program lines upto the next E"
"LSE or ELSE IF command are executed, otherwise the program br"
"anches to the next ELSE or ELSE IF command.",  /* Description */
   "IF THEN",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_INPUT,  /* UniqueID */
   "INPUT [# device-number]|[;][\"prompt string\";] variable [, ..."
"]s",  /* Syntax */
   "Reads input from the terminal or athe file specified by devic"
"e-number.",  /* Description */
   "INPUT",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_LET,  /* UniqueID */
   "[LET] variable = expression",  /* Syntax */
   "Assigns the value of expression to variable.  The 'LET' keywo"
"rd is optional.",  /* Description */
   "LET",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_LINE,  /* UniqueID */
   "LINE INPUT [[#] device-number,][\"prompt string\";] string-vari"
"able$",  /* Syntax */
   "Reads entire line from the keyboard or a file into string-var"
"iable$.",  /* Description */
   "LINE",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_LIST,  /* UniqueID */
   "LIST line1 [- line2]",  /* Syntax */
   "Lists BASIC program lines from 'line1' to 'line2'",  /* Description */
   "LIST",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_LOAD,  /* UniqueID */
   "LOAD [file-name$]",  /* Syntax */
   "Loads an ASCII BASIC program into memory.",  /* Description */
   "LOAD",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_LOOP,  /* UniqueID */
   "LOOP",  /* Syntax */
   "Bottom of a DO - LOOP structure.  IF the loop is not terminat"
"ed by EXIT DO or DO UNTIL or DO WHILE, then it will loop fore"
"ver.",  /* Description */
   "LOOP",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_LOOP_UNTIL,  /* UniqueID */
   "LOOP UNTIL",  /* Syntax */
   "Bottom of a DO - LOOP structure.  If the expression is zero, "
"then the loop is terminated.",  /* Description */
   "LOOP UNTIL",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_LOOP_WHILE,  /* UniqueID */
   "LOOP WHILE",  /* Syntax */
   "Bottom of a DO - LOOP structure.  If the expression is non-ze"
"ro, then the loop is terminated.",  /* Description */
   "LOOP WHILE",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_LPRINT,  /* UniqueID */
   "LPRINT [USING format-string$;] expressions...",  /* Syntax */
   "Send output to the default printer which is implementation de"
"fined.",  /* Description */
   "LPRINT",  /* Name */
   B14 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_LSET,  /* UniqueID */
   "LSET string-variable$ = expression",  /* Syntax */
   "Left-aligns the value of expression into string-variable$.  I"
"f the length of the value is too short, then it is padded on "
"the right with spaces.  If the length of the value is too lon"
"g, then it is truncated on the right.  This is only for use w"
"ith variables assigned to a random access buffer with FIELD c"
"ommand.",  /* Description */
   "LSET",  /* Name */
   B14 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_MAINTAINER,  /* UniqueID */
   "MAINTAINER",  /* Syntax */
   "This command is reserved for use by the Bywater BASIC maintai"
"ner and does whatever the maintainer wants it to do.  It is n"
"ot for the BASIC programmer.",  /* Description */
   "MAINTAINER",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_MERGE,  /* UniqueID */
   "MERGE file-name",  /* Syntax */
   "Merges the BASIC program in file-name into the current BASIC "
"program.  Lines in file-name replace any matching lines in th"
"e current program.",  /* Description */
   "MERGE",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_MID_,  /* UniqueID */
   "MID$( variable$, start [, count ] ) = expression",  /* Syntax */
   "Replaces a subtring of variable$ with expression.",  /* Description */
   "MID$",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_NAME,  /* UniqueID */
   "NAME old-file-name AS new-file-name",  /* Syntax */
   "Changes the name of an existing file.",  /* Description */
   "NAME",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_NEW,  /* UniqueID */
   "NEW",  /* Syntax */
   "Deletes the program in memory and clears all variables.",  /* Description */
   "NEW",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_NEXT,  /* UniqueID */
   "NEXT [variable]",  /* Syntax */
   "The bottom line of a FOR - NEXT structure.",  /* Description */
   "NEXT",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_ON,  /* UniqueID */
   "ON expression GOTO | GOSUB line [, ...]",  /* Syntax */
   "Branches (GOTO) or calls (GOSUB) based on the rounded value o"
"f variable.",  /* Description */
   "ON",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_ON_ERROR_GOSUB,  /* UniqueID */
   "ON ERROR GOSUB errline",  /* Syntax */
   "When a trappable error occurs, execute 'GOSUB errline'.  The "
"error handler must terminate with a RETURN command.  If the l"
"ine number is 0 (zerp), then use the default error handler.  "
"Valid when OPTION ERROR GOSUB.",  /* Description */
   "ON ERROR GOSUB",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_ON_ERROR_GOTO,  /* UniqueID */
   "ON ERROR GOTO errline",  /* Syntax */
   "When a trappable error occurs, execute 'GOTO errline'.  The e"
"rror handler must terminate with a RESUME command.  If the li"
"ne number is 0 (zerp), then use the default error handler.  V"
"alid when OPTION ERROR GOTO.",  /* Description */
   "ON ERROR GOTO",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_ON_ERROR_RESUME_NEXT,  /* UniqueID */
   "ON ERROR RESUME NEXT",  /* Syntax */
   "When a trappable error occurs, execution continues with the n"
"ext line.  Valid when OPTION ERROR GOTO.",  /* Description */
   "ON ERROR RESUME NEXT",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_ON_ERROR_RETURN_NEXT,  /* UniqueID */
   "ON ERROR RETURN NEXT",  /* Syntax */
   "When a trappable error occurs, execution continues with the n"
"ext line.  Valid when OPTION ERROR GOSUB.",  /* Description */
   "ON ERROR RETURN NEXT",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_ON_TIMER,  /* UniqueID */
   "ON TIMER count GOSUB line",  /* Syntax */
   "Specifies a line (or label) to gosub when count seconds have "
"elaspsed after TIMER ON is executed.  The interrupt routine s"
"hould end with a RETURN command.  Timer events only occur in "
"running BASIC programs.  The resolution of the clock is imple"
"mentation defined.",  /* Description */
   "ON TIMER",  /* Name */
   B14 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_OPEN,  /* UniqueID */
   "OPEN file-name [FOR INPUT|OUTPUT|APPEND|BINARY|RANDOM] AS [#]"
"device-number [LEN = record-length]",  /* Syntax */
   "Opens a file for use.  INPUT, OUTPUT, and APPEND are for text"
" files.  BINARY is for binary files.  RANDOM is for structure"
"d binary files and requires LEN.  Files opened for RANDOM use"
" GET and PUT.",  /* Description */
   "OPEN",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_OPTION,  /* UniqueID */
   "OPTION ...",  /* Syntax */
   "OPTION by itself is a syntax error.",  /* Description */
   "OPTION",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_OPTION_ANGLE_DEGREES,  /* UniqueID */
   "OPTION ANGLE DEGREES",  /* Syntax */
   "Configures the math functions to accept and return angles in "
"degrees.",  /* Description */
   "OPTION ANGLE DEGREES",  /* Name */
   B14 | E86  /* OptionVersionBitmask */
},
{
   C_OPTION_ANGLE_RADIANS,  /* UniqueID */
   "OPTION ANGLE RADIANS",  /* Syntax */
   "Configures the math functions to accept and return angles in "
"radians.",  /* Description */
   "OPTION ANGLE RADIANS",  /* Name */
   B14 | E86  /* OptionVersionBitmask */
},
{
   C_OPTION_ARITHMETIC_DECIMAL,  /* UniqueID */
   "OPTION ARITHMETIC DECIMAL",  /* Syntax */
   "Currently has no effect.",  /* Description */
   "OPTION ARITHMETIC DECIMAL",  /* Name */
   B14 | E86  /* OptionVersionBitmask */
},
{
   C_OPTION_ARITHMETIC_FIXED,  /* UniqueID */
   "OPTION ARITHMETIC FIXED",  /* Syntax */
   "Currently has no effect.",  /* Description */
   "OPTION ARITHMETIC FIXED",  /* Name */
   B14 | E86  /* OptionVersionBitmask */
},
{
   C_OPTION_ARITHMETIC_NATIVE,  /* UniqueID */
   "OPTION ARITHMETIC NATIVE",  /* Syntax */
   "Currently has no effect.",  /* Description */
   "OPTION ARITHMETIC NATIVE",  /* Name */
   B14 | E86  /* OptionVersionBitmask */
},
{
   C_OPTION_BASE_0,  /* UniqueID */
   "OPTION BASE 0",  /* Syntax */
   "Sets the lowest array subscript to 0.",  /* Description */
   "OPTION BASE 0",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_OPTION_BASE_1,  /* UniqueID */
   "OPTION BASE 1",  /* Syntax */
   "Sets the lowest array subscript to 1.",  /* Description */
   "OPTION BASE 1",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_OPTION_BUGS_OFF,  /* UniqueID */
   "OPTION BUGS OFF",  /* Syntax */
   "Disables bugs commonly found in BASIC-80 derivatives and clon"
"es.",  /* Description */
   "OPTION BUGS OFF",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_BUGS_ON,  /* UniqueID */
   "OPTION BUGS ON",  /* Syntax */
   "Enables bugs commonly found in BASIC-80 derivatives and clone"
"s.",  /* Description */
   "OPTION BUGS ON",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_COMMENT,  /* UniqueID */
   "OPTION COMMENT char",  /* Syntax */
   "Sets the comment character.",  /* Description */
   "OPTION COMMENT",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_COMPARE_BINARY,  /* UniqueID */
   "OPTION COMPARE BINARY",  /* Syntax */
   "Causes string comparisons to be case-sensitive.",  /* Description */
   "OPTION COMPARE BINARY",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_COMPARE_DATABASE,  /* UniqueID */
   "OPTION COMPARE DATABASE",  /* Syntax */
   "Causes string comparisons to be case-insensitive.",  /* Description */
   "OPTION COMPARE DATABASE",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_COMPARE_TEXT,  /* UniqueID */
   "OPTION COMPARE TEXT",  /* Syntax */
   "Causes string comparisons to be case-insensitive.",  /* Description */
   "OPTION COMPARE TEXT",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_COVERAGE_OFF,  /* UniqueID */
   "OPTION COVERAGE OFF",  /* Syntax */
   "Disables BASIC code coverage recording, displayed using the L"
"IST command.",  /* Description */
   "OPTION COVERAGE OFF",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_COVERAGE_ON,  /* UniqueID */
   "OPTION COVERAGE ON",  /* Syntax */
   "Enables BASIC code coverage recording, displayed using the LI"
"ST command.",  /* Description */
   "OPTION COVERAGE ON",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_DATE,  /* UniqueID */
   "OPTION DATE format",  /* Syntax */
   "Sets the date format string used by C strftime() for DATE$.",  /* Description */
   "OPTION DATE",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_DISABLE_COMMAND,  /* UniqueID */
   "OPTION DISABLE COMMAND name",  /* Syntax */
   "Disables the specified BASIC command.",  /* Description */
   "OPTION DISABLE COMMAND",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_DISABLE_FUNCTION,  /* UniqueID */
   "OPTION DISABLE FUNCTION name",  /* Syntax */
   "Disables the specified BASIC function.",  /* Description */
   "OPTION DISABLE FUNCTION",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_DISABLE_OPERATOR,  /* UniqueID */
   "OPTION DISABLE OPERATOR name",  /* Syntax */
   "Disables the specified BASIC operator.",  /* Description */
   "OPTION DISABLE OPERATOR",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_ENABLE_COMMAND,  /* UniqueID */
   "OPTION ENABLE COMMAND name",  /* Syntax */
   "Enables the specified BASIC command.",  /* Description */
   "OPTION ENABLE COMMAND",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_ENABLE_FUNCTION,  /* UniqueID */
   "OPTION ENABLE FUNCTION name",  /* Syntax */
   "Enables the specified BASIC function.",  /* Description */
   "OPTION ENABLE FUNCTION",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_ENABLE_OPERATOR,  /* UniqueID */
   "OPTION ENABLE OPERATOR name",  /* Syntax */
   "Enables the specified BASIC operator.",  /* Description */
   "OPTION ENABLE OPERATOR",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_ERROR_GOSUB,  /* UniqueID */
   "OPTION ERROR GOSUB",  /* Syntax */
   "When an error occurs, GOSUB to the error handler.  The error "
"handler exits with RETURN.",  /* Description */
   "OPTION ERROR GOSUB",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_ERROR_GOTO,  /* UniqueID */
   "OPTION ERROR GOTO",  /* Syntax */
   "When an error occurs, GOTO to the error handler.  The error h"
"andler exits with RESUME.",  /* Description */
   "OPTION ERROR GOTO",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_INDENT,  /* UniqueID */
   "OPTION INDENT number",  /* Syntax */
   "Sets indention level for LIST.  Zero means no indention.  Def"
"ault is 2.",  /* Description */
   "OPTION INDENT",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_LABELS_OFF,  /* UniqueID */
   "OPTION LABELS OFF",  /* Syntax */
   "Disables text labels.",  /* Description */
   "OPTION LABELS OFF",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_LABELS_ON,  /* UniqueID */
   "OPTION LABELS ON",  /* Syntax */
   "Enables text labels.",  /* Description */
   "OPTION LABELS ON",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_STATEMENT,  /* UniqueID */
   "OPTION STATEMENT char",  /* Syntax */
   "Sets the statement seperator character.",  /* Description */
   "OPTION STATEMENT",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_STRICT_OFF,  /* UniqueID */
   "OPTION STRICT OFF",  /* Syntax */
   "Disables checking for implicit array creation without using t"
"he DIM command.",  /* Description */
   "OPTION STRICT OFF",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_STRICT_ON,  /* UniqueID */
   "OPTION STRICT ON",  /* Syntax */
   "Enables checking for implicit array creation without using th"
"e DIM command.",  /* Description */
   "OPTION STRICT ON",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_TERMINAL_ADM_3A,  /* UniqueID */
   "OPTION TERMINAL ADM-3A",  /* Syntax */
   "Enables ADM-3A terminal control codes for CLS, COLOR, and LOC"
"ATE.",  /* Description */
   "OPTION TERMINAL ADM-3A",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_TERMINAL_ANSI,  /* UniqueID */
   "OPTION TERMINAL ANSI",  /* Syntax */
   "Enables ANSI terminal control codes for CLS, COLOR, and LOCAT"
"E.",  /* Description */
   "OPTION TERMINAL ANSI",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_TERMINAL_NONE,  /* UniqueID */
   "OPTION TERMINAL NONE",  /* Syntax */
   "Disables terminal control codes for CLS, COLOR, and LOCATE.",  /* Description */
   "OPTION TERMINAL NONE",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_TIME,  /* UniqueID */
   "OPTION TIME format",  /* Syntax */
   "Sets the time format string used by C strftime() for TIME$.",  /* Description */
   "OPTION TIME",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_TRACE_OFF,  /* UniqueID */
   "OPTION TRACE OFF",  /* Syntax */
   "Disables displaying a stack trace when an ERROR occurs.",  /* Description */
   "OPTION TRACE OFF",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_TRACE_ON,  /* UniqueID */
   "OPTION TRACE ON",  /* Syntax */
   "Enables displaying a stack trace when an ERROR occurs.",  /* Description */
   "OPTION TRACE ON",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_OPTION_VERSION,  /* UniqueID */
   "OPTION VERSION [version] ",  /* Syntax */
   "Selects a combination of OPTION settings and enables certain "
"commands and functions.  If no version is specified, displays"
" a list of the available versions.",  /* Description */
   "OPTION VERSION",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_PRINT,  /* UniqueID */
   "PRINT [# device-number,][USING format-string$;] expressions.."
".",  /* Syntax */
   "Sends output to the console or a file.",  /* Description */
   "PRINT",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_QUIT,  /* UniqueID */
   "QUIT",  /* Syntax */
   "Exits to the operating system.",  /* Description */
   "QUIT",  /* Name */
   B14 | D64 | E78 | E86  /* OptionVersionBitmask */
},
{
   C_READ,  /* UniqueID */
   "READ variable [, ...]",  /* Syntax */
   "Reads values from DATA statements.",  /* Description */
   "READ",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_REM,  /* UniqueID */
   "REM ...",  /* Syntax */
   "Remark.",  /* Description */
   "REM",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_RENUM,  /* UniqueID */
   "RENUM",  /* Syntax */
   "Implementation defined.",  /* Description */
   "RENUM",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_RESTORE,  /* UniqueID */
   "RESTORE [line]",  /* Syntax */
   "Resets the line used for the next READ statement.  'line' may"
" be either a number or a label.",  /* Description */
   "RESTORE",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_RESUME,  /* UniqueID */
   "RESUME [ 0 | line | NEXT ]",  /* Syntax */
   "Used in an error handler to specify the next line to execute."
"  RESUME and RESUME 0 branch to ERL.  RESUME NEXT branches to"
" the line after ERL.  RESUME line branches to the specified l"
"ine.  'line' may be either a number or a label.",  /* Description */
   "RESUME",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_RETURN,  /* UniqueID */
   "RETURN",  /* Syntax */
   "Concludes a subroutine called by GOSUB.",  /* Description */
   "RETURN",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_RSET,  /* UniqueID */
   "RSET string-variable$ = expression",  /* Syntax */
   "Right-aligns the value of expression into string-variable$.  "
"If the length of the value is too short, then it is padded on"
" the left with spaces.  If the length of the value is too lon"
"g, then it is truncated on the right.  This is only for use w"
"ith variables assigned to a random access buffer with FIELD c"
"ommand.",  /* Description */
   "RSET",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_RUN,  /* UniqueID */
   "RUN [line | file-name$]",  /* Syntax */
   "RUN executes the program in memory from the start.  RUN line "
"exexecutes the program in memory beginning at 'line'.  RUN fi"
"le-name$ loads a new BAASIC program and executes the program "
"from the start.",  /* Description */
   "RUN",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_SAVE,  /* UniqueID */
   "SAVE [file-name$]",  /* Syntax */
   "Saves the current program into the file file-name$ in ASCII f"
"ormat.",  /* Description */
   "SAVE",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_SELECT,  /* UniqueID */
   "SELECT",  /* Syntax */
   "SELECT by itself is a syntax error.  Use SELECT CASE instead."
"",  /* Description */
   "SELECT",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_SELECT_CASE,  /* UniqueID */
   "SELECT CASE expression",  /* Syntax */
   "Introduces a multi-line conditional selection statement.",  /* Description */
   "SELECT CASE",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_STOP,  /* UniqueID */
   "STOP",  /* Syntax */
   "Interrupts program execution and displays the line number of "
"the STOP command.  For use when debugging BASIC programs.  Wh"
"ether STOP issues a SIGINT signal is implementation defined.",  /* Description */
   "STOP",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_SUB,  /* UniqueID */
   "SUB name [ ( parameter [,...] ) ]",  /* Syntax */
   "Top line of a multi-line SUB definition.  The variable names "
"specified are local to the SUB definition, and are initialize"
"d BYVAL when the subroutine is invoked by another routine.",  /* Description */
   "SUB",  /* Name */
   B14 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_SWAP,  /* UniqueID */
   "SWAP variable, variable",  /* Syntax */
   "Swaps the values of two variables. Both variables must be of "
"the same type.",  /* Description */
   "SWAP",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_SYSTEM,  /* UniqueID */
   "SYSTEM",  /* Syntax */
   "Exits to the operating system.",  /* Description */
   "SYSTEM",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_TIMER,  /* UniqueID */
   "TIMER",  /* Syntax */
   "TIMER by itself is a syntax error.  Use TIMER OFF, TIMER ON, "
"or TIMER STOP instead.",  /* Description */
   "TIMER",  /* Name */
   B14 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_TIMER_OFF,  /* UniqueID */
   "TIMER OFF",  /* Syntax */
   "TIMER OFF terminates the timer interrupt.",  /* Description */
   "TIMER OFF",  /* Name */
   B14 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_TIMER_ON,  /* UniqueID */
   "TIMER ON",  /* Syntax */
   "TIMER ON enables the timer interrupt.  When the specified sec"
"onds have elapsed, TIMER STOP is internaly executed before th"
"e interrupt is taken.  TIMER ON should be executed just befor"
"e the RETURN command if you want the interrupt to occur again"
".",  /* Description */
   "TIMER ON",  /* Name */
   B14 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_TIMER_STOP,  /* UniqueID */
   "TIMER STOP",  /* Syntax */
   "TIMER STOP disables the interrupt, but the count continues.",  /* Description */
   "TIMER STOP",  /* Name */
   B14 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_UEND,  /* UniqueID */
   "UEND",  /* Syntax */
   "Bottom of a UNTIL - UEND structure.",  /* Description */
   "UEND",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_UNTIL,  /* UniqueID */
   "UNTIL expression",  /* Syntax */
   "Top of a UNTIL - UEND structure.  If the expression is zero, "
"then the loop is terminated.",  /* Description */
   "UNTIL",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_USER_LBL,  /* UniqueID */
   "USER LBL",  /* Syntax */
   "An internal command that allows the BASIC program to find a u"
"ser label.  You do not directly call this command.  If your p"
"rogram has a line with a label, then USER LBL is used to mark"
" the line.",  /* Description */
   "USER LBL",  /* Name */
   B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_VARS,  /* UniqueID */
   "VARS",  /* Syntax */
   "Prints a list of all global variables.",  /* Description */
   "VARS",  /* Name */
   B14  /* OptionVersionBitmask */
},
{
   C_WEND,  /* UniqueID */
   "WEND",  /* Syntax */
   "Bottom of a WHILE - WEND structure.",  /* Description */
   "WEND",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_WHILE,  /* UniqueID */
   "WHILE",  /* Syntax */
   "Top of a WHILE - WEND structure.  If the expression is non-ze"
"ro, then the loop is terminated.",  /* Description */
   "WHILE",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
{
   C_WRITE,  /* UniqueID */
   "WRITE [# device-number,] element [, .... ]",  /* Syntax */
   "Outputs variables to the screen or to a file.",  /* Description */
   "WRITE",  /* Name */
   B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98  /* OptionVersionBitmask */
},
};

/* FUNCTIONS */
#define F_ABS_X_N                        1 /* N  = ABS( X )                  */
#define F_ACOS_X_N                       2 /* N  = ACOS( X )                 */
#define F_ANGLE_X_Y_N                    3 /* N  = ANGLE( X, Y )             */
#define F_ARGC_N                         4 /* N  = ARGC                      */
#define F_ARGT_X_S                       5 /* S$ = ARGT$( X )                */
#define F_ARGV_X_N                       6 /* N  = ARGV( X )                 */
#define F_ARGV_X_S                       7 /* S$ = ARGV$( X )                */
#define F_ASC_A_N                        8 /* N  = ASC( A$ )                 */
#define F_ASIN_X_N                       9 /* N  = ASIN( X )                 */
#define F_ATN_X_N                       10 /* N  = ATN( X )                  */
#define F_CCUR_X_N                      11 /* N  = CCUR( X )                 */
#define F_CDBL_X_N                      12 /* N  = CDBL( X )                 */
#define F_CEIL_X_N                      13 /* N  = CEIL( X )                 */
#define F_CHDIR_A_N                     14 /* N  = CHDIR( A$ )               */
#define F_CHR_X_S                       15 /* S$ = CHR$( X )                 */
#define F_CINT_X_N                      16 /* N  = CINT( X )                 */
#define F_CLNG_X_N                      17 /* N  = CLNG( X )                 */
#define F_CLOSE_X_N                     18 /* N  = CLOSE( X )                */
#define F_CLS_N                         19 /* N  = CLS                       */
#define F_COLOR_X_Y_N                   20 /* N  = COLOR( X, Y )             */
#define F_COS_X_N                       21 /* N  = COS( X )                  */
#define F_COSH_X_N                      22 /* N  = COSH( X )                 */
#define F_COT_X_N                       23 /* N  = COT( X )                  */
#define F_CSC_X_N                       24 /* N  = CSC( X )                  */
#define F_CSNG_X_N                      25 /* N  = CSNG( X )                 */
#define F_CVC_A_N                       26 /* N  = CVC( A$ )                 */
#define F_CVD_A_N                       27 /* N  = CVD( A$ )                 */
#define F_CVI_A_N                       28 /* N  = CVI( A$ )                 */
#define F_CVL_A_N                       29 /* N  = CVL( A$ )                 */
#define F_CVS_A_N                       30 /* N  = CVS( A$ )                 */
#define F_DATE_N                        31 /* N  = DATE                      */
#define F_DATE_S                        32 /* S$ = DATE$                     */
#define F_DEF_FN_N                      33 /* N  = DEF FN                    */
#define F_DEG_X_N                       34 /* N  = DEG( X )                  */
#define F_ENVIRON_A_N                   35 /* N  = ENVIRON( A$ )             */
#define F_ENVIRON_A_S                   36 /* S$ = ENVIRON$( A$ )            */
#define F_EOF_X_N                       37 /* N  = EOF( X )                  */
#define F_EPS_X_N                       38 /* N  = EPS( X )                  */
#define F_ERL_N                         39 /* N  = ERL                       */
#define F_ERR_N                         40 /* N  = ERR                       */
#define F_ERR_S                         41 /* S$ = ERR$                      */
#define F_ERROR_X_N                     42 /* N  = ERROR( X )                */
#define F_ERROR_X_A_N                   43 /* N  = ERROR( X, A$ )            */
#define F_EXP_X_N                       44 /* N  = EXP( X )                  */
#define F_FILEATTR_X_Y_N                45 /* N  = FILEATTR( X, Y )          */
#define F_FILES_N                       46 /* N  = FILES                     */
#define F_FILES_A_N                     47 /* N  = FILES( A$ )               */
#define F_FIX_X_N                       48 /* N  = FIX( X )                  */
#define F_FP_X_N                        49 /* N  = FP( X )                   */
#define F_FRE_N                         50 /* N  = FRE                       */
#define F_FRE_X_N                       51 /* N  = FRE( X )                  */
#define F_FRE_A_N                       52 /* N  = FRE( A$ )                 */
#define F_FREEFILE_N                    53 /* N  = FREEFILE                  */
#define F_GET_X_N                       54 /* N  = GET( X )                  */
#define F_GET_X_Y_N                     55 /* N  = GET( X, Y )               */
#define F_HEX_X_S                       56 /* S$ = HEX$( X )                 */
#define F_INKEY_S                       57 /* S$ = INKEY$                    */
#define F_INP_X_N                       58 /* N  = INP( X )                  */
#define F_INPUT_X_S                     59 /* S$ = INPUT$( X )               */
#define F_INPUT_X_Y_S                   60 /* S$ = INPUT$( X, Y )            */
#define F_INSTR_A_B_N                   61 /* N  = INSTR( A$, B$ )           */
#define F_INSTR_X_A_B_N                 62 /* N  = INSTR( X, A$, B$ )        */
#define F_INT_X_N                       63 /* N  = INT( X )                  */
#define F_IP_X_N                        64 /* N  = IP( X )                   */
#define F_KILL_A_N                      65 /* N  = KILL( A$ )                */
#define F_LCASE_A_S                     66 /* S$ = LCASE$( A$ )              */
#define F_LEFT_A_X_S                    67 /* S$ = LEFT$( A$, X )            */
#define F_LEN_A_N                       68 /* N  = LEN( A$ )                 */
#define F_LOC_X_N                       69 /* N  = LOC( X )                  */
#define F_LOCATE_X_Y_N                  70 /* N  = LOCATE( X, Y )            */
#define F_LOF_X_N                       71 /* N  = LOF( X )                  */
#define F_LOG_X_N                       72 /* N  = LOG( X )                  */
#define F_LOG10_X_N                     73 /* N  = LOG10( X )                */
#define F_LOG2_X_N                      74 /* N  = LOG2( X )                 */
#define F_LPOS_N                        75 /* N  = LPOS                      */
#define F_LTRIM_A_S                     76 /* S$ = LTRIM$( A$ )              */
#define F_LWIDTH_X_N                    77 /* N  = LWIDTH( X )               */
#define F_MAX_X_Y_N                     78 /* N  = MAX( X, Y )               */
#define F_MAXBYT_N                      79 /* N  = MAXBYT                    */
#define F_MAXCUR_N                      80 /* N  = MAXCUR                    */
#define F_MAXDBL_N                      81 /* N  = MAXDBL                    */
#define F_MAXDEV_N                      82 /* N  = MAXDEV                    */
#define F_MAXINT_N                      83 /* N  = MAXINT                    */
#define F_MAXLEN_A_N                    84 /* N  = MAXLEN( A$ )              */
#define F_MAXLNG_N                      85 /* N  = MAXLNG                    */
#define F_MAXLVL_N                      86 /* N  = MAXLVL                    */
#define F_MAXNUM_N                      87 /* N  = MAXNUM                    */
#define F_MAXSNG_N                      88 /* N  = MAXSNG                    */
#define F_MID_A_X_S                     89 /* S$ = MID$( A$, X )             */
#define F_MID_A_X_Y_S                   90 /* S$ = MID$( A$, X, Y )          */
#define F_MIN_X_Y_N                     91 /* N  = MIN( X, Y )               */
#define F_MINBYT_N                      92 /* N  = MINBYT                    */
#define F_MINCUR_N                      93 /* N  = MINCUR                    */
#define F_MINDBL_N                      94 /* N  = MINDBL                    */
#define F_MINDEV_N                      95 /* N  = MINDEV                    */
#define F_MININT_N                      96 /* N  = MININT                    */
#define F_MINLNG_N                      97 /* N  = MINLNG                    */
#define F_MINNUM_N                      98 /* N  = MINNUM                    */
#define F_MINSNG_N                      99 /* N  = MINSNG                    */
#define F_MKC_X_S                      100 /* S$ = MKC$( X )                 */
#define F_MKD_X_S                      101 /* S$ = MKD$( X )                 */
#define F_MKDIR_A_N                    102 /* N  = MKDIR( A$ )               */
#define F_MKI_X_S                      103 /* S$ = MKI$( X )                 */
#define F_MKL_X_S                      104 /* S$ = MKL$( X )                 */
#define F_MKS_X_S                      105 /* S$ = MKS$( X )                 */
#define F_MOD_X_Y_N                    106 /* N  = MOD( X, Y )               */
#define F_NAME_A_B_N                   107 /* N  = NAME( A$, B$ )            */
#define F_NULL_X_N                     108 /* N  = NULL( X )                 */
#define F_OCT_X_S                      109 /* S$ = OCT$( X )                 */
#define F_OPEN_A_X_B_N                 110 /* N  = OPEN( A$, X, B$ )         */
#define F_OPEN_A_X_B_Y_N               111 /* N  = OPEN( A$, X, B$, Y )      */
#define F_ORD_A_N                      112 /* N  = ORD( A$ )                 */
#define F_OUT_X_Y_N                    113 /* N  = OUT( X, Y )               */
#define F_PEEK_X_N                     114 /* N  = PEEK( X )                 */
#define F_PI_N                         115 /* N  = PI                        */
#define F_POKE_X_Y_N                   116 /* N  = POKE( X, Y )              */
#define F_POS_N                        117 /* N  = POS                       */
#define F_POS_X_N                      118 /* N  = POS( X )                  */
#define F_POS_A_B_N                    119 /* N  = POS( A$, B$ )             */
#define F_POS_A_B_X_N                  120 /* N  = POS( A$, B$, X )          */
#define F_PUT_X_N                      121 /* N  = PUT( X )                  */
#define F_PUT_X_Y_N                    122 /* N  = PUT( X, Y )               */
#define F_RAD_X_N                      123 /* N  = RAD( X )                  */
#define F_RANDOMIZE_N                  124 /* N  = RANDOMIZE                 */
#define F_RANDOMIZE_X_N                125 /* N  = RANDOMIZE( X )            */
#define F_REMAINDER_X_Y_N              126 /* N  = REMAINDER( X, Y )         */
#define F_REPEAT_X_Y_S                 127 /* S$ = REPEAT$( X, Y )           */
#define F_REPEAT_X_A_S                 128 /* S$ = REPEAT$( X, A$ )          */
#define F_RESET_N                      129 /* N  = RESET                     */
#define F_RIGHT_A_X_S                  130 /* S$ = RIGHT$( A$, X )           */
#define F_RMDIR_A_N                    131 /* N  = RMDIR( A$ )               */
#define F_RND_N                        132 /* N  = RND                       */
#define F_RND_X_N                      133 /* N  = RND( X )                  */
#define F_ROUND_X_Y_N                  134 /* N  = ROUND( X, Y )             */
#define F_RTRIM_A_S                    135 /* S$ = RTRIM$( A$ )              */
#define F_SEC_X_N                      136 /* N  = SEC( X )                  */
#define F_SEEK_X_N                     137 /* N  = SEEK( X )                 */
#define F_SEEK_X_Y_N                   138 /* N  = SEEK( X, Y )              */
#define F_SGN_X_N                      139 /* N  = SGN( X )                  */
#define F_SHELL_A_N                    140 /* N  = SHELL( A$ )               */
#define F_SIN_X_N                      141 /* N  = SIN( X )                  */
#define F_SINH_X_N                     142 /* N  = SINH( X )                 */
#define F_SPACE_X_S                    143 /* S$ = SPACE$( X )               */
#define F_SPC_X_S                      144 /* S$ = SPC( X )                  */
#define F_SQR_X_N                      145 /* N  = SQR( X )                  */
#define F_STR_X_S                      146 /* S$ = STR$( X )                 */
#define F_STRING_X_A_S                 147 /* S$ = STRING$( X, A$ )          */
#define F_STRING_X_Y_S                 148 /* S$ = STRING$( X, Y )           */
#define F_TAB_X_S                      149 /* S$ = TAB( X )                  */
#define F_TAN_X_N                      150 /* N  = TAN( X )                  */
#define F_TANH_X_N                     151 /* N  = TANH( X )                 */
#define F_TIME_N                       152 /* N  = TIME                      */
#define F_TIME_S                       153 /* S$ = TIME$                     */
#define F_TIMER_N                      154 /* N  = TIMER                     */
#define F_TRIM_A_S                     155 /* S$ = TRIM$( A$ )               */
#define F_TROFF_N                      156 /* N  = TROFF                     */
#define F_TRON_N                       157 /* N  = TRON                      */
#define F_TRUNCATE_X_Y_N               158 /* N  = TRUNCATE( X, Y )          */
#define F_UCASE_A_S                    159 /* S$ = UCASE$( A$ )              */
#define F_VAL_A_N                      160 /* N  = VAL( A$ )                 */
#define F_WAIT_X_Y_N                   161 /* N  = WAIT( X, Y )              */
#define F_WAIT_X_Y_Z_N                 162 /* N  = WAIT( X, Y, Z )           */
#define F_WIDTH_X_N                    163 /* N  = WIDTH( X )                */
#define F_WIDTH_X_Y_N                  164 /* N  = WIDTH( X, Y )             */
#define NUM_FUNCTIONS 164
/* SWITCH */
switch( UniqueID )
{
case F_ABS_X_N:
    break;
case F_ACOS_X_N:
    break;
case F_ANGLE_X_Y_N:
    break;
case F_ARGC_N:
    break;
case F_ARGT_X_S:
    break;
case F_ARGV_X_N:
    break;
case F_ARGV_X_S:
    break;
case F_ASC_A_N:
    break;
case F_ASIN_X_N:
    break;
case F_ATN_X_N:
    break;
case F_CCUR_X_N:
    break;
case F_CDBL_X_N:
    break;
case F_CEIL_X_N:
    break;
case F_CHDIR_A_N:
    break;
case F_CHR_X_S:
    break;
case F_CINT_X_N:
    break;
case F_CLNG_X_N:
    break;
case F_CLOSE_X_N:
    break;
case F_CLS_N:
    break;
case F_COLOR_X_Y_N:
    break;
case F_COS_X_N:
    break;
case F_COSH_X_N:
    break;
case F_COT_X_N:
    break;
case F_CSC_X_N:
    break;
case F_CSNG_X_N:
    break;
case F_CVC_A_N:
    break;
case F_CVD_A_N:
    break;
case F_CVI_A_N:
    break;
case F_CVL_A_N:
    break;
case F_CVS_A_N:
    break;
case F_DATE_N:
    break;
case F_DATE_S:
    break;
case F_DEF_FN_N:
    break;
case F_DEG_X_N:
    break;
case F_ENVIRON_A_N:
    break;
case F_ENVIRON_A_S:
    break;
case F_EOF_X_N:
    break;
case F_EPS_X_N:
    break;
case F_ERL_N:
    break;
case F_ERR_N:
    break;
case F_ERR_S:
    break;
case F_ERROR_X_N:
    break;
case F_ERROR_X_A_N:
    break;
case F_EXP_X_N:
    break;
case F_FILEATTR_X_Y_N:
    break;
case F_FILES_N:
    break;
case F_FILES_A_N:
    break;
case F_FIX_X_N:
    break;
case F_FP_X_N:
    break;
case F_FRE_N:
    break;
case F_FRE_X_N:
    break;
case F_FRE_A_N:
    break;
case F_FREEFILE_N:
    break;
case F_GET_X_N:
    break;
case F_GET_X_Y_N:
    break;
case F_HEX_X_S:
    break;
case F_INKEY_S:
    break;
case F_INP_X_N:
    break;
case F_INPUT_X_S:
    break;
case F_INPUT_X_Y_S:
    break;
case F_INSTR_A_B_N:
    break;
case F_INSTR_X_A_B_N:
    break;
case F_INT_X_N:
    break;
case F_IP_X_N:
    break;
case F_KILL_A_N:
    break;
case F_LCASE_A_S:
    break;
case F_LEFT_A_X_S:
    break;
case F_LEN_A_N:
    break;
case F_LOC_X_N:
    break;
case F_LOCATE_X_Y_N:
    break;
case F_LOF_X_N:
    break;
case F_LOG_X_N:
    break;
case F_LOG10_X_N:
    break;
case F_LOG2_X_N:
    break;
case F_LPOS_N:
    break;
case F_LTRIM_A_S:
    break;
case F_LWIDTH_X_N:
    break;
case F_MAX_X_Y_N:
    break;
case F_MAXBYT_N:
    break;
case F_MAXCUR_N:
    break;
case F_MAXDBL_N:
    break;
case F_MAXDEV_N:
    break;
case F_MAXINT_N:
    break;
case F_MAXLEN_A_N:
    break;
case F_MAXLNG_N:
    break;
case F_MAXLVL_N:
    break;
case F_MAXNUM_N:
    break;
case F_MAXSNG_N:
    break;
case F_MID_A_X_S:
    break;
case F_MID_A_X_Y_S:
    break;
case F_MIN_X_Y_N:
    break;
case F_MINBYT_N:
    break;
case F_MINCUR_N:
    break;
case F_MINDBL_N:
    break;
case F_MINDEV_N:
    break;
case F_MININT_N:
    break;
case F_MINLNG_N:
    break;
case F_MINNUM_N:
    break;
case F_MINSNG_N:
    break;
case F_MKC_X_S:
    break;
case F_MKD_X_S:
    break;
case F_MKDIR_A_N:
    break;
case F_MKI_X_S:
    break;
case F_MKL_X_S:
    break;
case F_MKS_X_S:
    break;
case F_MOD_X_Y_N:
    break;
case F_NAME_A_B_N:
    break;
case F_NULL_X_N:
    break;
case F_OCT_X_S:
    break;
case F_OPEN_A_X_B_N:
    break;
case F_OPEN_A_X_B_Y_N:
    break;
case F_ORD_A_N:
    break;
case F_OUT_X_Y_N:
    break;
case F_PEEK_X_N:
    break;
case F_PI_N:
    break;
case F_POKE_X_Y_N:
    break;
case F_POS_N:
    break;
case F_POS_X_N:
    break;
case F_POS_A_B_N:
    break;
case F_POS_A_B_X_N:
    break;
case F_PUT_X_N:
    break;
case F_PUT_X_Y_N:
    break;
case F_RAD_X_N:
    break;
case F_RANDOMIZE_N:
    break;
case F_RANDOMIZE_X_N:
    break;
case F_REMAINDER_X_Y_N:
    break;
case F_REPEAT_X_Y_S:
    break;
case F_REPEAT_X_A_S:
    break;
case F_RESET_N:
    break;
case F_RIGHT_A_X_S:
    break;
case F_RMDIR_A_N:
    break;
case F_RND_N:
    break;
case F_RND_X_N:
    break;
case F_ROUND_X_Y_N:
    break;
case F_RTRIM_A_S:
    break;
case F_SEC_X_N:
    break;
case F_SEEK_X_N:
    break;
case F_SEEK_X_Y_N:
    break;
case F_SGN_X_N:
    break;
case F_SHELL_A_N:
    break;
case F_SIN_X_N:
    break;
case F_SINH_X_N:
    break;
case F_SPACE_X_S:
    break;
case F_SPC_X_S:
    break;
case F_SQR_X_N:
    break;
case F_STR_X_S:
    break;
case F_STRING_X_A_S:
    break;
case F_STRING_X_Y_S:
    break;
case F_TAB_X_S:
    break;
case F_TAN_X_N:
    break;
case F_TANH_X_N:
    break;
case F_TIME_N:
    break;
case F_TIME_S:
    break;
case F_TIMER_N:
    break;
case F_TRIM_A_S:
    break;
case F_TROFF_N:
    break;
case F_TRON_N:
    break;
case F_TRUNCATE_X_Y_N:
    break;
case F_UCASE_A_S:
    break;
case F_VAL_A_N:
    break;
case F_WAIT_X_Y_N:
    break;
case F_WAIT_X_Y_Z_N:
    break;
case F_WIDTH_X_N:
    break;
case F_WIDTH_X_Y_N:
    break;
}
/* FUNCTION TABLE */

#include "bwbasic.h"

struct bwb_function bwb_prefuncs[ NUM_FUNCTIONS ] =
{
{
  F_ABS_X_N, /* UniqueID */
  "N  = ABS( X )", /* Syntax */
  "The absolute value of X.",  /* Description */
  "ABS", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_ACOS_X_N, /* UniqueID */
  "N  = ACOS( X )", /* Syntax */
  "The arccosine of X in radians, where 0 <= ACOS(X) <= PI.  X s"
"hall be in the range -1 <= X <= 1.",  /* Description */
  "ACOS", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_ANGLE_X_Y_N, /* UniqueID */
  "N  = ANGLE( X, Y )", /* Syntax */
  "The angle in radians between the positive x-axis and the vect"
"or joining the origin to the point with coordinates (X, Y), w"
"here -PI < ANGLE(X,Y) <= PI.  X and Y must not both be 0.  No"
"te that the counterclockwise is positive, e.g., ANGLE(1,1) = "
"45 degrees.",  /* Description */
  "ANGLE", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1ANY | P2ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_ARGC_N, /* UniqueID */
  "N  = ARGC", /* Syntax */
  "The number of parameters passed to a FUNCTION or SUB.  If not"
" in a FUNCTION or SUB, returns -1.",  /* Description */
  "ARGC", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_ARGT_X_S, /* UniqueID */
  "S$ = ARGT$( X )", /* Syntax */
  "The value of the X'th parameter to a FUNCTION or SUB; '$' or "
"'#'.  X in [1,ARGC].",  /* Description */
  "ARGT$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1INT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_ARGV_X_N, /* UniqueID */
  "N  = ARGV( X )", /* Syntax */
  "The value of the X'th parameter to a FUNCTION or SUB.  X in ["
"1,ARGC] and ARGT$( X ) = '#'.",  /* Description */
  "ARGV", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1INT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_ARGV_X_S, /* UniqueID */
  "S$ = ARGV$( X )", /* Syntax */
  "The value of the X'th parameter to a FUNCTION or SUB.  X in ["
"1,ARGC] and ARGT$( X ) = '$'.",  /* Description */
  "ARGV$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1INT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_ASC_A_N, /* UniqueID */
  "N  = ASC( A$ )", /* Syntax */
  "The ASCII code for the first letter in A$.",  /* Description */
  "ASC", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_ASIN_X_N, /* UniqueID */
  "N  = ASIN( X )", /* Syntax */
  "The arcsine of X in radians, where -PI/2 <= ASIN(X) <= PI/2; "
"X shall be in the range -1 <= X <= 1.",  /* Description */
  "ASIN", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_ATN_X_N, /* UniqueID */
  "N  = ATN( X )", /* Syntax */
  "The arctangent of X in radians, i.e. the angle whose tangent "
"is X, where -PI/2 < ATN(X) < PI/2.",  /* Description */
  "ATN", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_CCUR_X_N, /* UniqueID */
  "N  = CCUR( X )", /* Syntax */
  "The currency (64-bit) integer value of X.",  /* Description */
  "CCUR", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1CUR, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_CDBL_X_N, /* UniqueID */
  "N  = CDBL( X )", /* Syntax */
  "The double-precision value of X.",  /* Description */
  "CDBL", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1DBL, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_CEIL_X_N, /* UniqueID */
  "N  = CEIL( X )", /* Syntax */
  "The smallest integer not less than X.",  /* Description */
  "CEIL", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_CHDIR_A_N, /* UniqueID */
  "N  = CHDIR( A$ )", /* Syntax */
  "Changes to the directory named to A$.",  /* Description */
  "CHDIR", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_CHR_X_S, /* UniqueID */
  "S$ = CHR$( X )", /* Syntax */
  "The one-character string with the character corresponding to "
"the ASCII code X.",  /* Description */
  "CHR$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_CINT_X_N, /* UniqueID */
  "N  = CINT( X )", /* Syntax */
  "The short (16-bit) integer value of X.",  /* Description */
  "CINT", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1INT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_CLNG_X_N, /* UniqueID */
  "N  = CLNG( X )", /* Syntax */
  "The long (32-bit) integer value of X.",  /* Description */
  "CLNG", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1LNG, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_CLOSE_X_N, /* UniqueID */
  "N  = CLOSE( X )", /* Syntax */
  "Close file number X.",  /* Description */
  "CLOSE", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1DEV, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_CLS_N, /* UniqueID */
  "N  = CLS", /* Syntax */
  "Clears the screen. Cursor is positioned at row 1, column 1.",  /* Description */
  "CLS", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_COLOR_X_Y_N, /* UniqueID */
  "N  = COLOR( X, Y )", /* Syntax */
  "Sets the foreground text color to X, and the background text "
"color to Y.",  /* Description */
  "COLOR", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1BYT | P2BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_COS_X_N, /* UniqueID */
  "N  = COS( X )", /* Syntax */
  "The cosine of X, where X is in radians.",  /* Description */
  "COS", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_COSH_X_N, /* UniqueID */
  "N  = COSH( X )", /* Syntax */
  "The hyperbolic cosine of X.",  /* Description */
  "COSH", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_COT_X_N, /* UniqueID */
  "N  = COT( X )", /* Syntax */
  "The cotangent of X, where X is in radians.",  /* Description */
  "COT", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_CSC_X_N, /* UniqueID */
  "N  = CSC( X )", /* Syntax */
  "The cosecant of X, where X is in radians.",  /* Description */
  "CSC", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_CSNG_X_N, /* UniqueID */
  "N  = CSNG( X )", /* Syntax */
  "The single-precision value of X.",  /* Description */
  "CSNG", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1FLT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_CVC_A_N, /* UniqueID */
  "N  = CVC( A$ )", /* Syntax */
  "The currency (64-bit) integer value in A$, which was created "
"by MKC$.",  /* Description */
  "CVC", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1CUR, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_CVD_A_N, /* UniqueID */
  "N  = CVD( A$ )", /* Syntax */
  "The double-precision value in A$, which was created by MKD$.",  /* Description */
  "CVD", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1DBL, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_CVI_A_N, /* UniqueID */
  "N  = CVI( A$ )", /* Syntax */
  "The short (16-bit) integer value in A$, which was created by "
"MKI$.",  /* Description */
  "CVI", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1INT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_CVL_A_N, /* UniqueID */
  "N  = CVL( A$ )", /* Syntax */
  "The long (32-bit) integer value in A$, which was created by M"
"KL$.",  /* Description */
  "CVL", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1LNG, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_CVS_A_N, /* UniqueID */
  "N  = CVS( A$ )", /* Syntax */
  "The single-precision value in A$, which was created by MKS$.",  /* Description */
  "CVS", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1FLT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_DATE_N, /* UniqueID */
  "N  = DATE", /* Syntax */
  "The current date in decimal form YYYDDD, where YYY are the nu"
"mber of years since 1900 and DDD is the ordinal number of the"
" current day of the year; e.g., the value of DATE on May 9, 1"
"977 was 77129.  If there is no calendar available, then the v"
"alue of DATE shall be -1.",  /* Description */
  "DATE", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_DATE_S, /* UniqueID */
  "S$ = DATE$", /* Syntax */
  "BASIC-80: The current date based on the computer's internal c"
"lock as a string in the form 'MM-DD-YYYY'.ECMA-116: The date "
"in the string representation 'YYYYMMDD' according to ISO 2014"
".  For example, the value of DATE$ on May 9, 1977 was '197705"
"09'.  If there is not calendar available, then the value of D"
"ATE$ shall be '00000000'.",  /* Description */
  "DATE$", /* Name */
  STRING, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_DEF_FN_N, /* UniqueID */
  "N  = DEF FN", /* Syntax */
  "User Function.",  /* Description */
  "DEF FN", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_DEG_X_N, /* UniqueID */
  "N  = DEG( X )", /* Syntax */
  "The number of degrees in X radians.",  /* Description */
  "DEG", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_ENVIRON_A_N, /* UniqueID */
  "N  = ENVIRON( A$ )", /* Syntax */
  "Sends the environment variable expression contained in A$ to "
"the host operating system.  A$ must contain the  '=' characte"
"r.",  /* Description */
  "ENVIRON", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_ENVIRON_A_S, /* UniqueID */
  "S$ = ENVIRON$( A$ )", /* Syntax */
  "The value of the environment variable named A$.",  /* Description */
  "ENVIRON$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_EOF_X_N, /* UniqueID */
  "N  = EOF( X )", /* Syntax */
  "If device number X is at the end-of-file, then -1, otherwise "
"0.",  /* Description */
  "EOF", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1DEV, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_EPS_X_N, /* UniqueID */
  "N  = EPS( X )", /* Syntax */
  "The maximum of (X-X1,X2-X, sigma) where X1 and X2 are the pre"
"decessor and successor of X and signma is the smallest positi"
"ve value representable.  If X has no predecessor the X1=X and"
" if X has no successor the X2=X.  Note EPS(0) is the smallest"
" positive number representable by the implementation, and is "
"therefor implementation-defined.  Note also that EPS may prod"
"uce different results for different arithmetic options (see O"
"PTION ARITHMETIC).",  /* Description */
  "EPS", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_ERL_N, /* UniqueID */
  "N  = ERL", /* Syntax */
  "The line number of the most recent error.",  /* Description */
  "ERL", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_ERR_N, /* UniqueID */
  "N  = ERR", /* Syntax */
  "The error number of the most recent error.",  /* Description */
  "ERR", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_ERR_S, /* UniqueID */
  "S$ = ERR$", /* Syntax */
  "The last error message.",  /* Description */
  "ERR$", /* Name */
  STRING, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_ERROR_X_N, /* UniqueID */
  "N  = ERROR( X )", /* Syntax */
  "Simulate the error number in X.",  /* Description */
  "ERROR", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_ERROR_X_A_N, /* UniqueID */
  "N  = ERROR( X, A$ )", /* Syntax */
  "Simulate the error number in X, with a custom message in A$.",  /* Description */
  "ERROR", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2STR, /* ParameterTypes */
  P1BYT | P2ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_EXP_X_N, /* UniqueID */
  "N  = EXP( X )", /* Syntax */
  "The exponential value of X, i.e., the value of the base of na"
"tural logarithms (e = 2.71828) raised to the power of X;  if "
"EXP(X) is less that machine infinitesimal, then its value sha"
"ll be replaced with zero.",  /* Description */
  "EXP", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_FILEATTR_X_Y_N, /* UniqueID */
  "N  = FILEATTR( X, Y )", /* Syntax */
  "For file X, if Y = 1 then returns open mode, otherwise return"
"s zero.",  /* Description */
  "FILEATTR", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1DEV | P2INT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_FILES_N, /* UniqueID */
  "N  = FILES", /* Syntax */
  "Displays all the file names.",  /* Description */
  "FILES", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_FILES_A_N, /* UniqueID */
  "N  = FILES( A$ )", /* Syntax */
  "Displays all the file names matching A$.",  /* Description */
  "FILES", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_FIX_X_N, /* UniqueID */
  "N  = FIX( X )", /* Syntax */
  "The truncated integer, part of X. FIX (X) is equivalent to SG"
"N(X)*INT(ABS(X)). The major difference between FIX and INT is"
" that FIX does not return the next lower number for negative "
"X.",  /* Description */
  "FIX", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_FP_X_N, /* UniqueID */
  "N  = FP( X )", /* Syntax */
  "The fractional part of X, i.e. X - IP(X).",  /* Description */
  "FP", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_FRE_N, /* UniqueID */
  "N  = FRE", /* Syntax */
  "The number of bytes of available memory.  This function is pr"
"ovided for backward compatibility and it always returns a fix"
"ed value of 32000.",  /* Description */
  "FRE", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_FRE_X_N, /* UniqueID */
  "N  = FRE( X )", /* Syntax */
  "The number of bytes of available memory.  This function is pr"
"ovided for backward compatibility and it always returns a fix"
"ed value of 32000.  The value of X is ignored.",  /* Description */
  "FRE", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_FRE_A_N, /* UniqueID */
  "N  = FRE( A$ )", /* Syntax */
  "The number of bytes of available memory.  This function is pr"
"ovided for backward compatibility and it always returns a fix"
"ed value of 32000.The value of A$ is ignored.",  /* Description */
  "FRE", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_FREEFILE_N, /* UniqueID */
  "N  = FREEFILE", /* Syntax */
  "The next available file number.",  /* Description */
  "FREEFILE", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_GET_X_N, /* UniqueID */
  "N  = GET( X )", /* Syntax */
  "For file X, gets the next available record.",  /* Description */
  "GET", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1DEV, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_GET_X_Y_N, /* UniqueID */
  "N  = GET( X, Y )", /* Syntax */
  "For file X, gets record number Y.  The first record number is"
" 1.",  /* Description */
  "GET", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1DEV | P2INT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_HEX_X_S, /* UniqueID */
  "S$ = HEX$( X )", /* Syntax */
  "The the hexadecimal (base 16) representation of X.",  /* Description */
  "HEX$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1INT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_INKEY_S, /* UniqueID */
  "S$ = INKEY$", /* Syntax */
  "The keypress, if available. If a keypress is not available, t"
"hen immediately returns a null string ('').  If not supported"
" by the platform, then always returns an empty string, so use"
" INPUT$(1) instead.",  /* Description */
  "INKEY$", /* Name */
  STRING, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_INP_X_N, /* UniqueID */
  "N  = INP( X )", /* Syntax */
  "The value read from machine port X.  Not supported on all pla"
"tforms.",  /* Description */
  "INP", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_INPUT_X_S, /* UniqueID */
  "S$ = INPUT$( X )", /* Syntax */
  "The string of X characters, read from the terminal.",  /* Description */
  "INPUT$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1LEN, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_INPUT_X_Y_S, /* UniqueID */
  "S$ = INPUT$( X, Y )", /* Syntax */
  "The string of X characters, read from file Y.",  /* Description */
  "INPUT$", /* Name */
  STRING, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1LEN | P2DEV, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_INSTR_A_B_N, /* UniqueID */
  "N  = INSTR( A$, B$ )", /* Syntax */
  "The position at which B$ occurs in A$, beginning at position "
"1.",  /* Description */
  "INSTR", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1STR | P2STR, /* ParameterTypes */
  P1ANY | P2ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_INSTR_X_A_B_N, /* UniqueID */
  "N  = INSTR( X, A$, B$ )", /* Syntax */
  "The position at which B$ occurs in A$, beginning at position "
"X.",  /* Description */
  "INSTR", /* Name */
  NUMBER, /* ReturnType */
  3, /* ParameterCount */
  P1NUM | P2STR | P3STR, /* ParameterTypes */
  P1POS | P2ANY | P3ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_INT_X_N, /* UniqueID */
  "N  = INT( X )", /* Syntax */
  "The largest integer not greater than X; e.g. INT(1.3) = 1 and"
" INT(-1.3) = 2.",  /* Description */
  "INT", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_IP_X_N, /* UniqueID */
  "N  = IP( X )", /* Syntax */
  "The integer part of X, i.e., SGN(X)*INT(ABS(X)).",  /* Description */
  "IP", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_KILL_A_N, /* UniqueID */
  "N  = KILL( A$ )", /* Syntax */
  "Removes the file named in A$.",  /* Description */
  "KILL", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_LCASE_A_S, /* UniqueID */
  "S$ = LCASE$( A$ )", /* Syntax */
  "The string of characters from the value associatedwith A$ by "
"replacing each upper-case-letter in the string by its lower-c"
"ase version.",  /* Description */
  "LCASE$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_LEFT_A_X_S, /* UniqueID */
  "S$ = LEFT$( A$, X )", /* Syntax */
  "The X left-most characters of A$, beginning from postion 1.",  /* Description */
  "LEFT$", /* Name */
  STRING, /* ReturnType */
  2, /* ParameterCount */
  P1STR | P2NUM, /* ParameterTypes */
  P1ANY | P2LEN, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_LEN_A_N, /* UniqueID */
  "N  = LEN( A$ )", /* Syntax */
  "The length of A$.",  /* Description */
  "LEN", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_LOC_X_N, /* UniqueID */
  "N  = LOC( X )", /* Syntax */
  "The location of file X; the next record that GET or PUT state"
"ments will use.",  /* Description */
  "LOC", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1DEV, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_LOCATE_X_Y_N, /* UniqueID */
  "N  = LOCATE( X, Y )", /* Syntax */
  "Locates the cursor to row X, column Y.",  /* Description */
  "LOCATE", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1BYT | P2BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_LOF_X_N, /* UniqueID */
  "N  = LOF( X )", /* Syntax */
  "The length of file X.",  /* Description */
  "LOF", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1DEV, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_LOG_X_N, /* UniqueID */
  "N  = LOG( X )", /* Syntax */
  "The natural logarithm of X; X shall be greater than zero.",  /* Description */
  "LOG", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1GTZ, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_LOG10_X_N, /* UniqueID */
  "N  = LOG10( X )", /* Syntax */
  "The common logarithm of X; X shall be greater than zero.",  /* Description */
  "LOG10", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1GTZ, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_LOG2_X_N, /* UniqueID */
  "N  = LOG2( X )", /* Syntax */
  "The base 2 logarithm of X; X shall be greater than zero.",  /* Description */
  "LOG2", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1GTZ, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_LPOS_N, /* UniqueID */
  "N  = LPOS", /* Syntax */
  "The current cursor position in the line for the printer.",  /* Description */
  "LPOS", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_LTRIM_A_S, /* UniqueID */
  "S$ = LTRIM$( A$ )", /* Syntax */
  "The string of characters resulting from the value associated "
"with A$ by deleting all leading space characters.",  /* Description */
  "LTRIM$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_LWIDTH_X_N, /* UniqueID */
  "N  = LWIDTH( X )", /* Syntax */
  "For printer, sets the line width to X. Zero means no wrapping"
" will occur.",  /* Description */
  "LWIDTH", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_MAX_X_Y_N, /* UniqueID */
  "N  = MAX( X, Y )", /* Syntax */
  "The smaller (algebraically) of the parameters.",  /* Description */
  "MAX", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1ANY | P2ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_MAXBYT_N, /* UniqueID */
  "N  = MAXBYT", /* Syntax */
  "The largest finite positive number representable as a BYTE; i"
"mplementation-defined.",  /* Description */
  "MAXBYT", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MAXCUR_N, /* UniqueID */
  "N  = MAXCUR", /* Syntax */
  "The largest finite positive number representable as a CURRENC"
"Y; implementation-defined.",  /* Description */
  "MAXCUR", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MAXDBL_N, /* UniqueID */
  "N  = MAXDBL", /* Syntax */
  "The largest finite positive number representable as a DOUBLE;"
" implementation-defined.",  /* Description */
  "MAXDBL", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MAXDEV_N, /* UniqueID */
  "N  = MAXDEV", /* Syntax */
  "The largest finite positive number useable as a FILE NUMBER; "
"implementation-defined.",  /* Description */
  "MAXDEV", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MAXINT_N, /* UniqueID */
  "N  = MAXINT", /* Syntax */
  "The largest finite positive number representable as an INTEGE"
"R; implementation-defined.",  /* Description */
  "MAXINT", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MAXLEN_A_N, /* UniqueID */
  "N  = MAXLEN( A$ )", /* Syntax */
  "The maximum length associated with the simple-string-variable"
" A$.",  /* Description */
  "MAXLEN", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_MAXLNG_N, /* UniqueID */
  "N  = MAXLNG", /* Syntax */
  "The largest finite positive number representable as a LONG; i"
"mplementation-defined.",  /* Description */
  "MAXLNG", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MAXLVL_N, /* UniqueID */
  "N  = MAXLVL", /* Syntax */
  "The maximum stack level; implementation-defined.",  /* Description */
  "MAXLVL", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MAXNUM_N, /* UniqueID */
  "N  = MAXNUM", /* Syntax */
  "The largest finite positive number representable and manipula"
"ble by the implementation; implementation-defined.  MAXNUM ma"
"y represent diffent number for different arithmetic options ("
"see OPTION ARITHMETIC).",  /* Description */
  "MAXNUM", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_MAXSNG_N, /* UniqueID */
  "N  = MAXSNG", /* Syntax */
  "The largest finite positive number representable as a SINGLE;"
" implementation-defined.",  /* Description */
  "MAXSNG", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MID_A_X_S, /* UniqueID */
  "S$ = MID$( A$, X )", /* Syntax */
  "The characters of A$, starting from postion X.",  /* Description */
  "MID$", /* Name */
  STRING, /* ReturnType */
  2, /* ParameterCount */
  P1STR | P2NUM, /* ParameterTypes */
  P1ANY | P2POS, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_MID_A_X_Y_S, /* UniqueID */
  "S$ = MID$( A$, X, Y )", /* Syntax */
  "The Y characters of A$, starting from postion X.",  /* Description */
  "MID$", /* Name */
  STRING, /* ReturnType */
  3, /* ParameterCount */
  P1STR | P2NUM | P3NUM, /* ParameterTypes */
  P1ANY | P2POS | P3LEN, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_MIN_X_Y_N, /* UniqueID */
  "N  = MIN( X, Y )", /* Syntax */
  "The smaller (algebraically) of the parameters.",  /* Description */
  "MIN", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1ANY | P2ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_MINBYT_N, /* UniqueID */
  "N  = MINBYT", /* Syntax */
  "The largest finite negative number representable as a BYTE; i"
"mplementation-defined.",  /* Description */
  "MINBYT", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MINCUR_N, /* UniqueID */
  "N  = MINCUR", /* Syntax */
  "The largest finite negative number representable as a CURRENC"
"Y; implementation-defined.",  /* Description */
  "MINCUR", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MINDBL_N, /* UniqueID */
  "N  = MINDBL", /* Syntax */
  "The largest finite negative number representable as a DOUBLE;"
" implementation-defined.",  /* Description */
  "MINDBL", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MINDEV_N, /* UniqueID */
  "N  = MINDEV", /* Syntax */
  "The largest finite negative number useable as a FILE NUMBER; "
"implementation-defined.",  /* Description */
  "MINDEV", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MININT_N, /* UniqueID */
  "N  = MININT", /* Syntax */
  "The largest finite negative number representable as an INTEGE"
"R; implementation-defined.",  /* Description */
  "MININT", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MINLNG_N, /* UniqueID */
  "N  = MINLNG", /* Syntax */
  "The largest finite negative number representable as a LONG; i"
"mplementation-defined.",  /* Description */
  "MINLNG", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MINNUM_N, /* UniqueID */
  "N  = MINNUM", /* Syntax */
  "The largest finite negative number representable and manipula"
"ble by the implementation; implementation-defined.  MINNUM ma"
"y represent diffent number for different arithmetic options ("
"see OPTION ARITHMETIC).",  /* Description */
  "MINNUM", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MINSNG_N, /* UniqueID */
  "N  = MINSNG", /* Syntax */
  "The largest finite negative number representable as a SINGLE;"
" implementation-defined.",  /* Description */
  "MINSNG", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MKC_X_S, /* UniqueID */
  "S$ = MKC$( X )", /* Syntax */
  "The internal representation of the currency (64-bit) integer "
"X as a string.",  /* Description */
  "MKC$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1CUR, /* ParameterTests */
  NULL, /* NextPointer */
  B14 /* OptionVersionBitmask */
},
{
  F_MKD_X_S, /* UniqueID */
  "S$ = MKD$( X )", /* Syntax */
  "The internal representation of X as a string.",  /* Description */
  "MKD$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1DBL, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_MKDIR_A_N, /* UniqueID */
  "N  = MKDIR( A$ )", /* Syntax */
  "Makes the directory named in A$.",  /* Description */
  "MKDIR", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_MKI_X_S, /* UniqueID */
  "S$ = MKI$( X )", /* Syntax */
  "The internal representation of the short (16-bit) integer X a"
"s a string.",  /* Description */
  "MKI$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1INT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_MKL_X_S, /* UniqueID */
  "S$ = MKL$( X )", /* Syntax */
  "The internal representation of the long (32-bit) integer X as"
" a string.",  /* Description */
  "MKL$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1LNG, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_MKS_X_S, /* UniqueID */
  "S$ = MKS$( X )", /* Syntax */
  "The internal representation of X as a string.",  /* Description */
  "MKS$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1FLT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_MOD_X_Y_N, /* UniqueID */
  "N  = MOD( X, Y )", /* Syntax */
  "X modulo Y, i.e., X-Y*INT(X/Y).  Y shall not equal zero.",  /* Description */
  "MOD", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1ANY | P2NEZ, /* ParameterTests */
  NULL, /* NextPointer */
  E86 /* OptionVersionBitmask */
},
{
  F_NAME_A_B_N, /* UniqueID */
  "N  = NAME( A$, B$ )", /* Syntax */
  "Rename the file named A$ into B$.",  /* Description */
  "NAME", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1STR | P2STR, /* ParameterTypes */
  P1BYT | P2BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_NULL_X_N, /* UniqueID */
  "N  = NULL( X )", /* Syntax */
  "Appends X null characters after each line printed by LPRINT o"
"r LLIST.",  /* Description */
  "NULL", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_OCT_X_S, /* UniqueID */
  "S$ = OCT$( X )", /* Syntax */
  "The the octal (base 8) representation of X.",  /* Description */
  "OCT$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1INT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_OPEN_A_X_B_N, /* UniqueID */
  "N  = OPEN( A$, X, B$ )", /* Syntax */
  "Open file number X.  A$ is the mode: I, O, A, R.  B$ is the f"
"ile name.  Default the record length.",  /* Description */
  "OPEN", /* Name */
  NUMBER, /* ReturnType */
  3, /* ParameterCount */
  P1STR | P2NUM | P3STR, /* ParameterTypes */
  P1BYT | P2DEV | P3BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_OPEN_A_X_B_Y_N, /* UniqueID */
  "N  = OPEN( A$, X, B$, Y )", /* Syntax */
  "Open file number X.  A$ is the mode: I, O, A, R.  B$ is the f"
"ile name.  Y is the record length.",  /* Description */
  "OPEN", /* Name */
  NUMBER, /* ReturnType */
  4, /* ParameterCount */
  P1STR | P2NUM | P3STR | P4NUM, /* ParameterTypes */
  P1BYT | P2DEV | P3BYT | P4INT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_ORD_A_N, /* UniqueID */
  "N  = ORD( A$ )", /* Syntax */
  "The ordinal position of the character named by the string ass"
"ociated with A$ in the collating sequence of ASCII character "
"set, where the first member of the character set is in positi"
"on zero.  The acceptable values for the standard character se"
"t are shown in Table 1.",  /* Description */
  "ORD", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_OUT_X_Y_N, /* UniqueID */
  "N  = OUT( X, Y )", /* Syntax */
  "Sends Y to hardware port X.  Not supported on all platforms.",  /* Description */
  "OUT", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1INT | P2BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_PEEK_X_N, /* UniqueID */
  "N  = PEEK( X )", /* Syntax */
  "The value read from hardware address X.  Not supported on all"
" platforms.",  /* Description */
  "PEEK", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1LNG, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_PI_N, /* UniqueID */
  "N  = PI", /* Syntax */
  "The constant 3.14159 which is the ratio of the circumference "
"of a circle to its diameter.",  /* Description */
  "PI", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_POKE_X_Y_N, /* UniqueID */
  "N  = POKE( X, Y )", /* Syntax */
  "Sends Y to hardware address X.  Not supported on all platform"
"s.",  /* Description */
  "POKE", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1LNG | P2BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_POS_N, /* UniqueID */
  "N  = POS", /* Syntax */
  "The current cursor position in the line.",  /* Description */
  "POS", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_POS_X_N, /* UniqueID */
  "N  = POS( X )", /* Syntax */
  "The current cursor position in the line for file X.",  /* Description */
  "POS", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1DEV, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_POS_A_B_N, /* UniqueID */
  "N  = POS( A$, B$ )", /* Syntax */
  "The character position, within the value assocated with A$, o"
"f the first character of the first occurence of the value ass"
"ociated with B$, starting at the first character of A$.  If t"
"here is not such occurence, then the value returned is zero.",  /* Description */
  "POS", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1STR | P2STR, /* ParameterTypes */
  P1ANY | P2ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_POS_A_B_X_N, /* UniqueID */
  "N  = POS( A$, B$, X )", /* Syntax */
  "The character position, within the value assocated with A$, o"
"f the first character of the first occurence of the value ass"
"ociated with B$, starting at the Xth character of A$.  If the"
"re is not such occurence, then the value returned is zero.",  /* Description */
  "POS", /* Name */
  NUMBER, /* ReturnType */
  3, /* ParameterCount */
  P1STR | P2STR | P3NUM, /* ParameterTypes */
  P1ANY | P2ANY | P3POS, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_PUT_X_N, /* UniqueID */
  "N  = PUT( X )", /* Syntax */
  "For file X, puts the next available record.",  /* Description */
  "PUT", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1DEV, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_PUT_X_Y_N, /* UniqueID */
  "N  = PUT( X, Y )", /* Syntax */
  "For file X, puts record number Y.  The first record number is"
" 1.",  /* Description */
  "PUT", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1DEV | P2INT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_RAD_X_N, /* UniqueID */
  "N  = RAD( X )", /* Syntax */
  "The number of radians in X degrees.",  /* Description */
  "RAD", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_RANDOMIZE_N, /* UniqueID */
  "N  = RANDOMIZE", /* Syntax */
  "Seeds the pseudo-random number generator with TIME.",  /* Description */
  "RANDOMIZE", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_RANDOMIZE_X_N, /* UniqueID */
  "N  = RANDOMIZE( X )", /* Syntax */
  "Seeds the pseudo-random number generator with X.",  /* Description */
  "RANDOMIZE", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_REMAINDER_X_Y_N, /* UniqueID */
  "N  = REMAINDER( X, Y )", /* Syntax */
  "The remainder function, i.e., X-Y*IP(X/Y).  Y shall not equal"
" zero.",  /* Description */
  "REMAINDER", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1ANY | P2NEZ, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_REPEAT_X_Y_S, /* UniqueID */
  "S$ = REPEAT$( X, Y )", /* Syntax */
  "The string consisting of X copies of CHR$(Y); X > 0.",  /* Description */
  "REPEAT$", /* Name */
  STRING, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1LEN | P2BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_REPEAT_X_A_S, /* UniqueID */
  "S$ = REPEAT$( X, A$ )", /* Syntax */
  "The string consisting of X copies of A$; X > 0.",  /* Description */
  "REPEAT$", /* Name */
  STRING, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2STR, /* ParameterTypes */
  P1LEN | P2BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_RESET_N, /* UniqueID */
  "N  = RESET", /* Syntax */
  "Close all open files.",  /* Description */
  "RESET", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_RIGHT_A_X_S, /* UniqueID */
  "S$ = RIGHT$( A$, X )", /* Syntax */
  "The right-most X characters of A$.",  /* Description */
  "RIGHT$", /* Name */
  STRING, /* ReturnType */
  2, /* ParameterCount */
  P1STR | P2NUM, /* ParameterTypes */
  P1ANY | P2LEN, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_RMDIR_A_N, /* UniqueID */
  "N  = RMDIR( A$ )", /* Syntax */
  "Removes the directory named in A$.",  /* Description */
  "RMDIR", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_RND_N, /* UniqueID */
  "N  = RND", /* Syntax */
  "The next pseudo-random number in an implementation-defined se"
"quence of pseudo-random numbers uniformly distributed in the "
"range 0 <= RND < 1.",  /* Description */
  "RND", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_RND_X_N, /* UniqueID */
  "N  = RND( X )", /* Syntax */
  "Returns a pseudorandom number in the range [0,1].  The value "
"of X is ignored.",  /* Description */
  "RND", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_ROUND_X_Y_N, /* UniqueID */
  "N  = ROUND( X, Y )", /* Syntax */
  "The value of X rounded to Y decimal digits to the right of th"
"e decimal point (or -Y digits to the left if Y < 0); i.e., IN"
"T(X*10^Y+.5)/10^Y.  Y must be in [-32,32].",  /* Description */
  "ROUND", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1ANY | P2INT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_RTRIM_A_S, /* UniqueID */
  "S$ = RTRIM$( A$ )", /* Syntax */
  "The string of characters resulting from the value associated "
"with A$ by deleting all trailing space characters.",  /* Description */
  "RTRIM$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_SEC_X_N, /* UniqueID */
  "N  = SEC( X )", /* Syntax */
  "The secant of X, where X is in radians.",  /* Description */
  "SEC", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_SEEK_X_N, /* UniqueID */
  "N  = SEEK( X )", /* Syntax */
  "The location of file X; the next record that GET or PUT state"
"ments will use.",  /* Description */
  "SEEK", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1DEV, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_SEEK_X_Y_N, /* UniqueID */
  "N  = SEEK( X, Y )", /* Syntax */
  "For file X, move to record number Y; the first record number "
"is 1.",  /* Description */
  "SEEK", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1DEV | P2INT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_SGN_X_N, /* UniqueID */
  "N  = SGN( X )", /* Syntax */
  "The sign of X: -1 if X < 0, 0 if X = 0, and +1 if X > 0.",  /* Description */
  "SGN", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_SHELL_A_N, /* UniqueID */
  "N  = SHELL( A$ )", /* Syntax */
  "The exit code resulting from the execution of an operating sy"
"stem command.",  /* Description */
  "SHELL", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_SIN_X_N, /* UniqueID */
  "N  = SIN( X )", /* Syntax */
  "The sine of X, where X is in radians.",  /* Description */
  "SIN", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_SINH_X_N, /* UniqueID */
  "N  = SINH( X )", /* Syntax */
  "The hyperbolic sine of X.",  /* Description */
  "SINH", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_SPACE_X_S, /* UniqueID */
  "S$ = SPACE$( X )", /* Syntax */
  "The string of X blank spaces.",  /* Description */
  "SPACE$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1LEN, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_SPC_X_S, /* UniqueID */
  "S$ = SPC( X )", /* Syntax */
  "The string of X blank spaces.  Only for use within the PRINT "
"command.",  /* Description */
  "SPC", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_SQR_X_N, /* UniqueID */
  "N  = SQR( X )", /* Syntax */
  "The non-negative square root of X;  X shall be non-negative.",  /* Description */
  "SQR", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1GEZ, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_STR_X_S, /* UniqueID */
  "S$ = STR$( X )", /* Syntax */
  "The string generated by the print-statement as the numeric-re"
"presentation of the value associated with X.",  /* Description */
  "STR$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_STRING_X_A_S, /* UniqueID */
  "S$ = STRING$( X, A$ )", /* Syntax */
  "The string X bytes long consisting of the first character of "
"A$.",  /* Description */
  "STRING$", /* Name */
  STRING, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2STR, /* ParameterTypes */
  P1LEN | P2BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_STRING_X_Y_S, /* UniqueID */
  "S$ = STRING$( X, Y )", /* Syntax */
  "The string X bytes long consisting of CHR$(Y).",  /* Description */
  "STRING$", /* Name */
  STRING, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1LEN | P2BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_TAB_X_S, /* UniqueID */
  "S$ = TAB( X )", /* Syntax */
  "The string required to advance to column X.  Only for use wit"
"hin the PRINT command.",  /* Description */
  "TAB", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_TAN_X_N, /* UniqueID */
  "N  = TAN( X )", /* Syntax */
  "The tangent of X, where X is in radians.",  /* Description */
  "TAN", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_TANH_X_N, /* UniqueID */
  "N  = TANH( X )", /* Syntax */
  "The hyperbolic tangent of X.",  /* Description */
  "TANH", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_TIME_N, /* UniqueID */
  "N  = TIME", /* Syntax */
  "The time elapsed since the previous midnight, expressed in se"
"conds; e.g., the value of TIME at 11:15 AM is 40500.  If ther"
"e is no clock available, then the value of TIME shall be -1. "
" The value of TIME at midnight shall be zero (not 86400).",  /* Description */
  "TIME", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_TIME_S, /* UniqueID */
  "S$ = TIME$", /* Syntax */
  "The time of day in 24-hour notation according to ISO 3307.  F"
"or example, the value of TIME$ at 11:15 AM is '11:15:00'.  If"
" there is no clock available, then the value of TIME$ shall b"
"e '99:99:99'.  The value of TIME$ at midnight is '00:00:00'.",  /* Description */
  "TIME$", /* Name */
  STRING, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_TIMER_N, /* UniqueID */
  "N  = TIMER", /* Syntax */
  "The time in the system clock in seconds elapsed since midnigh"
"t.",  /* Description */
  "TIMER", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_TRIM_A_S, /* UniqueID */
  "S$ = TRIM$( A$ )", /* Syntax */
  "The string resulting from removing both leading and trailing "
"spaces from A$.",  /* Description */
  "TRIM$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_TROFF_N, /* UniqueID */
  "N  = TROFF", /* Syntax */
  "Turn tracing OFF",  /* Description */
  "TROFF", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_TRON_N, /* UniqueID */
  "N  = TRON", /* Syntax */
  "Turn tracing ON",  /* Description */
  "TRON", /* Name */
  NUMBER, /* ReturnType */
  0, /* ParameterCount */
  PNONE, /* ParameterTypes */
  PNONE, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_TRUNCATE_X_Y_N, /* UniqueID */
  "N  = TRUNCATE( X, Y )", /* Syntax */
  "The value of X truncated to Y decimal digits to the right of "
"the decimal point (or -Y digits to the left if Y < 0); i.e., "
"IP(X*10^Y)/10^Y.  Y in [-32,32].",  /* Description */
  "TRUNCATE", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1ANY | P2INT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | E86 /* OptionVersionBitmask */
},
{
  F_UCASE_A_S, /* UniqueID */
  "S$ = UCASE$( A$ )", /* Syntax */
  "The string of characters resulting from the value associated "
"with A$ by replacing each lower-case-letter in the string by "
"its upper-case version.",  /* Description */
  "UCASE$", /* Name */
  STRING, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1ANY, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_VAL_A_N, /* UniqueID */
  "N  = VAL( A$ )", /* Syntax */
  "The value of the numeric-constant associated with A$, if the "
"string associated with A$ is a numeric-constant.  Leading and"
" trailing spaces in the string are ignored.  If the evaluatio"
"n of the numeric-constant would result in a value which cause"
"s an underflow, then the value returned shall be zero.  For e"
"xample, VAL(' 123.5 ' ) = 123.5, VAL('2.E-99') could be zero,"
" and VAL('MCMXVII') causes an exception.",  /* Description */
  "VAL", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1STR, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | D64 | E78 | M80 | T83 | T84 | M85 | E86 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_WAIT_X_Y_N, /* UniqueID */
  "N  = WAIT( X, Y )", /* Syntax */
  "Waits for the value of (INP(X) AND Y) to become nonzero.  Not"
" supported on all platforms.",  /* Description */
  "WAIT", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1INT | P2BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_WAIT_X_Y_Z_N, /* UniqueID */
  "N  = WAIT( X, Y, Z )", /* Syntax */
  "Waits for the value of ((INP(X) XOR Z) AND Y) to become nonze"
"ro.  Not supported on all platforms.",  /* Description */
  "WAIT", /* Name */
  NUMBER, /* ReturnType */
  3, /* ParameterCount */
  P1NUM | P2NUM | P3NUM, /* ParameterTypes */
  P1INT | P2BYT | P3BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_WIDTH_X_N, /* UniqueID */
  "N  = WIDTH( X )", /* Syntax */
  "For console, sets the line width to X. Zero means no wrapping"
" will occur.",  /* Description */
  "WIDTH", /* Name */
  NUMBER, /* ReturnType */
  1, /* ParameterCount */
  P1NUM, /* ParameterTypes */
  P1BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
{
  F_WIDTH_X_Y_N, /* UniqueID */
  "N  = WIDTH( X, Y )", /* Syntax */
  "For file X, sets the line width to Y.  Zero means no wrapping"
" will occur.",  /* Description */
  "WIDTH", /* Name */
  NUMBER, /* ReturnType */
  2, /* ParameterCount */
  P1NUM | P2NUM, /* ParameterTypes */
  P1DEV | P2BYT, /* ParameterTests */
  NULL, /* NextPointer */
  B14 | M80 | T83 | T84 | M85 | M88 | M90 | M91 | M92 | M93 | M95 | M97 | M98 /* OptionVersionBitmask */
},
};

